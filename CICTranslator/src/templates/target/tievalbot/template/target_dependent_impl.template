##MAIN_FUNCTION_START
int  main (void)
{
    OS_ERR  err;

    BSP_IntDisAll();                                            /* Disable all interrupts.                              */

    OSInit(&err);                                               /* Init uC/OS-III.                                      */

    OSTaskCreate((OS_TCB     *)&AppTaskRobotStartTCB,           /* Create the start task                                */
                 (CPU_CHAR   *)"App Task Start",
                 (OS_TASK_PTR ) AppTaskRobotStart,
                 (void       *) 0,
                 (OS_PRIO     ) APP_TASK_ROBOT_START_PRIO,
                 (CPU_STK    *)&AppTaskRobotStartStk[0],
                 (CPU_STK_SIZE) APP_TASK_ROBOT_START_STK_SIZE / 10u,
                 (CPU_STK_SIZE) APP_TASK_ROBOT_START_STK_SIZE,
                 (OS_MSG_QTY  ) 0u,
                 (OS_TICK     ) 0u,
                 (void       *) 0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR     *)&err);

    OSStart(&err);                                              /* Start multitasking (i.e. give control to uC/OS-III). */
}

static  void  AppTaskRobotStart (void  *p_arg)
##MAIN_FUNCTION_END

##TARGET_DEPENDENT_IMPLEMENTATION_START
static THREAD_TYPE arduino_task;
static int task_waiting_list[num_tasks] = {0, };
static int *read_waiting_list[num_channels];
static int *write_waiting_list[num_channels];

static OS_TCB AppTaskRobotStartTCB;
static CPU_STK AppTaskRobotStartStk[APP_TASK_ROBOT_START_STK_SIZE];

static void AppTaskRobotStart(void *p_arg);

static void interrupt_send(int task_idx)
{
      OS_ERR err;
      OSFlagPost(&tasks[task_idx].p_cond, 0x01, OS_OPT_POST_FLAG_SET, &err);
}

static void cic_task_sleep(int index, char op){
    OS_ERR err;
    int task_id = -1;
    int *r_waiting_list, *w_waiting_list;
    
    CPU_SR_ALLOC();
    
    OSSchedLock(&err);
    OS_CRITICAL_ENTER();
    if(op == 'r' || op == 'w'){
      task_id = find_task(channels[index].channel_id, op);
      OSMutexPend(&(channels[index].mutex), 0, OS_OPT_PEND_BLOCKING, NULL, &err);
 
      w_waiting_list = write_waiting_list[index];
      r_waiting_list = read_waiting_list[index];

      if(op == 'r')
      {
          r_waiting_list[task_id] = 1;
          
          int i=0;
          for(i=0;i<num_tasks;i++)
          {
            if(w_waiting_list[i] != 0){
              w_waiting_list[i] = 0;
              interrupt_send(i);
            }
          }
      }
      else if(op == 'w')
      {
          w_waiting_list[task_id] = 1;
          
          int i=0;
          for(i=0;i<num_tasks;i++)
          {
            if(r_waiting_list[i] != 0){
              r_waiting_list[i] = 0;
              interrupt_send(i);
            }
          }
      }
      OSMutexPost(&(channels[index].mutex), OS_OPT_POST_NONE, &err);;
    }
    else if(op == 't'){
      task_id = index;
      OSMutexPend(&(tasks[index].p_mutex), 0, OS_OPT_PEND_BLOCKING, NULL, &err);
      task_waiting_list[task_id] = 1;
      OSMutexPost(&(tasks[index].p_mutex), OS_OPT_POST_NONE, &err);;
    }
    OS_CRITICAL_EXIT();
    OSSchedUnlock(&err);

    OSFlagPend(&tasks[task_id].p_cond, 0x03, 0, OS_OPT_PEND_FLAG_SET_ANY + OS_OPT_PEND_FLAG_CONSUME, NULL, &err);
    if(err != OS_ERR_NONE){
        PRINT("OSFlagPend() failed!\n");
    }
}

static void cic_task_notify(int index, char op){
    int i=0;
    OS_ERR err;
    int *r_waiting_list, *w_waiting_list;
    
    CPU_SR_ALLOC();
    OSSchedLock(&err);
    OS_CRITICAL_ENTER();
    if(op == 'r' || op == 'w'){
        OSMutexPend(&(channels[index].mutex), 0, OS_OPT_PEND_BLOCKING, NULL, &err);
        w_waiting_list = write_waiting_list[index];
        r_waiting_list = read_waiting_list[index];

        if(op == 'r')
        {
            for(i=0;i<num_tasks;i++)
            {
                if(w_waiting_list[i] != 0)
                {
                    w_waiting_list[i] = 0;
                    interrupt_send(i);
                }
            }
        }
        else if(op == 'w')
        {
            for(i=0;i<num_tasks;i++)
            {
                if(r_waiting_list[i] != 0)
                {
                    r_waiting_list[i] = 0;
                    interrupt_send(i);
                }
            }
        }
        OSMutexPost(&(channels[index].mutex), OS_OPT_POST_NONE, &err);
    }
    else if(op == 't'){
      for(i=0;i<num_tasks;i++)
          {
              if(task_waiting_list[i] != 0)
              {
                  task_waiting_list[i] = 0;
                  interrupt_send(i);
              }
          }
    }
    OS_CRITICAL_EXIT();
    OSSchedUnlock(&err);
}

int init_lib_port(int library_id, const char op);

int get_channel_index(int ch_id)  //transform ch_id to its channels' index
{
  unsigned int i;
  for(i=0; i<num_channels; i++)
  {
      if(channels[i].channel_id == ch_id)
        return i;
  }

  PRINT("Warning : get_channel_index(): No port is available or connected\n");
    return -1;
}

THREAD_FUNC_RET_TYPE arduino_task_routine(THREAD_FUNC_ARG_TYPE pdata){
  OS_ERR err;
  unsigned long status_o, status_m, status_i;
  unsigned char data, len;
  char channel_id, lib_id;
  int cur_len, handShake = 0;
  unsigned char buf[255] = {0, };
  
  while(1){
    status_o = I2CSlaveStatus(I2C0_SLAVE_BASE);
    if(status_o == I2C_SLAVE_ACT_TREQ){   
        I2CSlaveDataPut(I2C0_SLAVE_BASE, 'a');
        while(1){
            status_o = I2CSlaveStatus(I2C0_SLAVE_BASE);
            if(status_o == I2C_SLAVE_ACT_RREQ || status_o == I2C_SLAVE_ACT_RREQ_FBR){
                unsigned char isStart = (char)I2CSlaveDataGet(I2C0_SLAVE_BASE);
                  if(isStart == 'z'){
                      handShake = 1;
                      break;
                  }
            }
        }
      }
    if(handShake == 1)  break;
  }
  
  while(1){
      status_o = I2CSlaveStatus(I2C0_SLAVE_BASE);
      if(status_o == I2C_SLAVE_ACT_RREQ || status_o == I2C_SLAVE_ACT_RREQ_FBR){
          channel_id = (char)I2CSlaveDataGet(I2C0_SLAVE_BASE);
          if(channel_id != 255){	// normal_channel
	          while(1){
	              status_m = I2CSlaveStatus(I2C0_SLAVE_BASE);
	              if(status_m == I2C_SLAVE_ACT_RREQ || status_m == I2C_SLAVE_ACT_RREQ_FBR){
	                len = (unsigned char)I2CSlaveDataGet(I2C0_SLAVE_BASE);
	                break;
	              }
	              OSTaskSemPend(1, OS_OPT_PEND_BLOCKING, 0, &err); 
	          }
	          cur_len = 0;
	          while(1){
	              status_i = I2CSlaveStatus(I2C0_SLAVE_BASE);
	              if(status_i == I2C_SLAVE_ACT_RREQ || status_i == I2C_SLAVE_ACT_RREQ_FBR){
	                   data = (unsigned char)I2CSlaveDataGet(I2C0_SLAVE_BASE);
	                   //BSP_DisplayStringDraw("    ", channel_id * 20, 0);
	                   //BSP_DisplayStringDraw("    ", channel_id * 20, 1);
	                   //BSP_printInt(channel_id, channel_id * 20, 0);
	                   //BSP_printInt(data, channel_id * 20, 1);
	                   
	                   int ch_id = get_channel_index((int)channel_id);
	                   
	                   if(channels[ch_id].type == CHANNEL_TYPE_NORMAL)      write_port(ch_id, (unsigned char*)&data, sizeof(unsigned char));
	                   else if(channels[ch_id].type == CHANNEL_TYPE_BUFFER) write_buf_port(ch_id, (unsigned char*)&data, sizeof(unsigned char));
	                   cur_len++;
	                   if(len <= cur_len)   break;
	               }
	               OSTaskSemPend(1, OS_OPT_PEND_BLOCKING, 0, &err); 
	           }
           }
           else{  // library channel
              while(1){
	              status_m = I2CSlaveStatus(I2C0_SLAVE_BASE);
	              if(status_m == I2C_SLAVE_ACT_RREQ || status_m == I2C_SLAVE_ACT_RREQ_FBR){
	                lib_id = (unsigned char)I2CSlaveDataGet(I2C0_SLAVE_BASE);
	                break;
	              }
	              OSTaskSemPend(1, OS_OPT_PEND_BLOCKING, 0, &err); 
	          }
           	  while(1){
	              status_m = I2CSlaveStatus(I2C0_SLAVE_BASE);
	              if(status_m == I2C_SLAVE_ACT_RREQ || status_m == I2C_SLAVE_ACT_RREQ_FBR){
	                len = (unsigned char)I2CSlaveDataGet(I2C0_SLAVE_BASE);
	                break;
	              }
	              OSTaskSemPend(1, OS_OPT_PEND_BLOCKING, 0, &err); 
	          }
	          cur_len = 0;
	          while(1){
	              status_i = I2CSlaveStatus(I2C0_SLAVE_BASE);
	              if(status_i == I2C_SLAVE_ACT_RREQ || status_i == I2C_SLAVE_ACT_RREQ_FBR){
	                   buf[cur_len] = (unsigned char)I2CSlaveDataGet(I2C0_SLAVE_BASE);
	                   cur_len++;
	                   if(len <= cur_len)   break;
	               }
	               OSTaskSemPend(1, OS_OPT_PEND_BLOCKING, 0, &err); 
	           }
	           int lib_ch_id = init_lib_port(lib_id, 'r');
	           write_lib_port(lib_ch_id, (unsigned char*)buf, lib_channels[lib_ch_id].sampleSize);
           }
      }
      else if(status_o == I2C_SLAVE_ACT_TREQ){
        int i=0;
        int index = -1;

        //for(i=0; i<num_channels; i++){
            // Need to implement
        //}
#ifdef LIB_CONN
        for(i=0; i<num_libchannels; i++){
          if(lib_channels[i].op == 'w'){
              int cur_size = lib_available(i);        
              if(cur_size >= lib_channels[i].sampleSize){
                  index = i;
	              read_lib_port(index, (unsigned char*)buf, lib_channels[i].sampleSize);
	              break;
	          }
          }
        }
#endif
        if(index == -1)     I2CSlaveDataPut(I2C0_SLAVE_BASE, (unsigned char)0);
#ifdef LIB_CONN
        else{
          I2CSlaveDataPut(I2C0_SLAVE_BASE, (unsigned char)2);   // 2 means "library channel"
          while(1){     // for send lib_channel_id
              status_m = I2CSlaveStatus(I2C0_SLAVE_BASE);
              if(status_m == I2C_SLAVE_ACT_TREQ){
                I2CSlaveDataPut(I2C0_SLAVE_BASE, (unsigned char)lib_channels[index].channel_id);
                break;
              }
          }
          while(1){     // for send data size
              status_m = I2CSlaveStatus(I2C0_SLAVE_BASE);
              if(status_m == I2C_SLAVE_ACT_TREQ){
                I2CSlaveDataPut(I2C0_SLAVE_BASE, (unsigned char)lib_channels[index].sampleSize);
                break;
              }
          }

          for(i=0; i<lib_channels[index].sampleSize; i++){
            while(1){     // for send data
              status_m = I2CSlaveStatus(I2C0_SLAVE_BASE);
              if(status_m == I2C_SLAVE_ACT_TREQ){
                  I2CSlaveDataPut(I2C0_SLAVE_BASE, (unsigned char)buf[i]);
                  break;
              }
            }
          }
        }
#endif
      }
      OSTaskSemPend(1, OS_OPT_PEND_BLOCKING, 0, &err); 
  }
}
static void Arduino_Conn_Init(){
    // Turn on I2S0 and reset to a known state
    SysCtlPeripheralEnable(SYSCTL_PERIPH_I2C0);
    SysCtlPeripheralReset(SYSCTL_PERIPH_I2C0);
    
    // Configure the PortB pins for I2C0
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
    GPIOPinTypeI2C(GPIO_PORTB_BASE, GPIO_PIN_2 | GPIO_PIN_3);
    
    // Set correct multiplexed pin 
    GPIOPinConfigure(GPIO_PB2_I2C0SCL);
    GPIOPinConfigure(GPIO_PB3_I2C0SDA);
    
    // Set GPIO Pins for Open-Drain operation
    GPIOPadConfigSet(GPIO_PORTB_BASE, GPIO_PIN_2, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_OD);
    GPIOPadConfigSet(GPIO_PORTB_BASE, GPIO_PIN_3, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_OD);
    
    // Give control to the I2C Module
    GPIODirModeSet(GPIO_PORTB_BASE, GPIO_PIN_2, GPIO_DIR_MODE_HW);
    GPIODirModeSet(GPIO_PORTB_BASE, GPIO_PIN_3, GPIO_DIR_MODE_HW);
    
    // Enable and Initialize MASTER/SLAVE
    I2CSlaveEnable(I2C0_SLAVE_BASE);
    I2CSlaveInit(I2C0_SLAVE_BASE, 0x3C);
    
    arduino_task.prio = OS_CFG_TICK_TASK_PRIO;
}


static void init_peripherals(){
    CPU_INT32U  clk_freq;
    CPU_INT32U  cnts;

    BSP_Init();                                                 /* Initialize BSP functions                             */
    CPU_Init();                                                 /* Initialize the uC/CPU services                       */
    Mem_Init();
    
    Arduino_Conn_Init();

    clk_freq = BSP_CPUClkFreq();                                /* Determine SysTick reference freq.                    */
    cnts     = clk_freq / (CPU_INT32U)OSCfg_TickRate_Hz;        /* Determine nbr SysTick increments                     */
    OS_CPU_SysTickInit(cnts);                                   /* Init uC/OS periodic time src (SysTick).              */
    CPU_TS_TmrFreqSet(clk_freq);

    CPU_IntDisMeasMaxCurReset();
}

static void target_dependent_init(){
    int i=0;
    LIB_ERR err;
    
    init_peripherals();

    for(i=0; i<num_tasks;i++){
      tasks[i].thread.prio = OS_CFG_TICK_TASK_PRIO;
      MUTEX_INIT(&tasks[i].p_mutex);
      COND_INIT(&tasks[i].p_cond);
    }
    
    for(i=0; i<num_channels; i++){
       read_waiting_list[i] = (int*)Mem_HeapAlloc(sizeof(int)*num_tasks, 16, NULL, &err);
       if(err != LIB_MEM_ERR_NONE) PRINT("Memalloc() failed!\n");

       write_waiting_list[i] = (int*)Mem_HeapAlloc(sizeof(int)*num_tasks, 16, NULL, &err);
       if(err != LIB_MEM_ERR_NONE) PRINT("Memalloc() failed!\n");
        
       Mem_Clr(read_waiting_list[i], sizeof(int)*num_tasks);
       Mem_Clr(write_waiting_list[i], sizeof(int)*num_tasks);
    }
}

static void target_dependent_wrapup(){
    int i=0;
    
    for(i = 0; i<num_libchannels; i++)
    {
      MUTEX_WRAPUP(&lib_channels[i].mutex);
      COND_WRAPUP(&lib_channels[i].cond);
    }
    
    for(i=0; i<num_channels; i++){
       free(read_waiting_list[i]);
       free(write_waiting_list[i]);
       MUTEX_WRAPUP(&channels[i].mutex);
       COND_WRAPUP(&channels[i].cond);
    }
    
    for(i=0; i<num_tasks;i++){
       MUTEX_WRAPUP(&tasks[i].p_mutex);
       COND_WRAPUP(&tasks[i].p_cond);
    }
}
##TARGET_DEPENDENT_IMPLEMENTATION_END