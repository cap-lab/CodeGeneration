##TARGET_DEPENDENT_START
MP mp, mp1;
int is_run=1;
int is_run2=1;
int done=0;
int done2=0;
double t=0;// t1
double t2=0;// t2

Matrix<double, 3, 2> mark;

dvec bx1,by1,bz1;
dvec bx2,by2,bz2;
dvec x,yy,z;
dvec x1,yy1,z1;
dvec x2,yy2,z2;
dvec x3,yy3,z3;
dvec x4,yy4,z4;
dvec xmr,ymr,zmr;
dvec xmg,ymg,zmg;
dvec xmb,ymb,zmb;

dvec tx,tyy,tz;
dvec tx1,tyy1,tz1;
dvec tx2,tyy2,tz2;
dvec tx3,tyy3,tz3;
dvec tx4,tyy4,tz4;

void generate_map(){
	int flag=1;
	int flag1=1;
	while (flag1){
		mark.row(0)<<0.5 * (rand() % 10) + 10, 0.5* (rand() % 10) + 10;
		if (mark.row(0).norm()!=0)
			flag1=0;
	}

	Matrix<double, 1, 2> mtemp1,mtemp2;
	while(flag){
		mtemp1<<0.5 *(rand() % 10) + 10, 0.5*(rand() % 10) + 10;
		mtemp2<<0.5 *(rand() % 10) + 10, 0.5*(rand() % 10) + 10;
		if (mark.row(0).norm()!=mtemp1.norm() && mark.row(0).norm()!=mtemp2.norm() && mtemp1.norm()!=mtemp2.norm() &&mtemp1.norm()!=0 && mtemp2.norm()!=0)
		{
			mark.row(1)<<mtemp1;
			mark.row(2)<<mtemp2;
			flag=0;
		}
	} // for generating a map in differnet area.
	//cout<<"Map:"<<mark<<endl;

}

class PL :public MatPlot{
	void DISPLAY(){
        if (t<(mp.step*(mp.Time))){
            done=0;
            mp.kinematics(); // inverse and forward kinematics();
        }
        else{
            done=1;
        }
        if (t2<(mp1.step*(mp1.Time)) && No_agent!=1){
            done2=0;
            mp1.kinematics(); // inverse and forward kinematics();
            //cout<<"OK here"<<endl;
        }
        else{
            done2=1;
        }
            //plot
        if (t<(mp.step*(mp.Time)) || t2<(mp1.step*(mp1.Time))){

            bx1.resize(mp.n);
            by1.resize(mp.n);
            bz1.resize(mp.n);

            bx2.resize(mp.n);
            by2.resize(mp.n);
            bz2.resize(mp.n);

            x.resize(5);
            yy.resize(5);
            z.resize(5);

            x1.resize(5);
            yy1.resize(5);
            z1.resize(5);

            x2.resize(5);
            yy2.resize(5);
            z2.resize(5);

            x3.resize(5);
            yy3.resize(5);
            z3.resize(5);

            x4.resize(8);
            yy4.resize(8);
            z4.resize(8);

            xmr.resize(5); // map
            ymr.resize(5);
            zmr.resize(5);

            xmg.resize(5);
            ymg.resize(5);
            zmg.resize(5);

            xmb.resize(5);
            ymb.resize(5);
            zmb.resize(5);

            tx.resize(5);
            tyy.resize(5);
            tz.resize(5);

            tx1.resize(5);
            tyy1.resize(5);
            tz1.resize(5);

            tx2.resize(5);
            tyy2.resize(5);
            tz2.resize(5);

            tx3.resize(5);
            tyy3.resize(5);
            tz3.resize(5);

            tx4.resize(8);
            tyy4.resize(8);
            tz4.resize(8);

            if (No_agent!=1){
            Matrix<double, 3, 8> tps_temp;

            tps_temp.row(0)<<mp1.ps(0,0),mp1.ps(0,1),mp1.ps(0,3),mp1.ps(0,2),mp1.ps(0,0),mp1.ps(0,3),mp1.ps(0,2),mp1.ps(0,1);
            tps_temp.row(1)<<mp1.ps(1,0),mp1.ps(1,1),mp1.ps(1,3),mp1.ps(1,2),mp1.ps(1,0),mp1.ps(1,3),mp1.ps(1,2),mp1.ps(1,1);
            tps_temp.row(2)<<mp1.ps(2,0),mp1.ps(2,1),mp1.ps(2,3),mp1.ps(2,2),mp1.ps(2,0),mp1.ps(2,3),mp1.ps(2,2),mp1.ps(2,1);

            for (int k=0;k<5;k++){
                tx[k]=mp1.p_lf(0,k);
                tyy[k]=mp1.p_lf(1,k);
                tz[k]=mp1.p_lf(2,k);

                tx1[k]=mp1.p_rf(0,k);
                tyy1[k]=mp1.p_rf(1,k);
                tz1[k]=mp1.p_rf(2,k);

                tx2[k]=mp1.p_lr(0,k);
                tyy2[k]=mp1.p_lr(1,k);
                tz2[k]=mp1.p_lr(2,k);

                tx3[k]=mp1.p_rr(0,k);
                tyy3[k]=mp1.p_rr(1,k);
                tz3[k]=mp1.p_rr(2,k);

                }
            for (int k=0;k<8;k++){
                tx4[k]=tps_temp(0,k);
                tyy4[k]=tps_temp(1,k);
                tz4[k]=tps_temp(2,k);
                }

           }


            Matrix<double, 3, 8> ps_temp;

            ps_temp.row(0)<<mp.ps(0,0),mp.ps(0,1),mp.ps(0,3),mp.ps(0,2),mp.ps(0,0),mp.ps(0,3),mp.ps(0,2),mp.ps(0,1);
            ps_temp.row(1)<<mp.ps(1,0),mp.ps(1,1),mp.ps(1,3),mp.ps(1,2),mp.ps(1,0),mp.ps(1,3),mp.ps(1,2),mp.ps(1,1);
            ps_temp.row(2)<<mp.ps(2,0),mp.ps(2,1),mp.ps(2,3),mp.ps(2,2),mp.ps(2,0),mp.ps(2,3),mp.ps(2,2),mp.ps(2,1);

            xmr[0]=mark(0,0)-0.25; xmr[1]=mark(0,0)+0.25; xmr[2]=mark(0,0)+0.25; xmr[3]=mark(0,0)-0.25; xmr[4]=mark(0,0)-0.25;
            ymr[0]=mark(0,1)-0.25; ymr[1]=mark(0,1)-0.25; ymr[2]=mark(0,1)+0.25; ymr[3]=mark(0,1)+0.25; ymr[4]=mark(0,1)-0.25;

            xmg[0]=mark(1,0)-0.25; xmg[1]=mark(1,0)+0.25; xmg[2]=mark(1,0)+0.25; xmg[3]=mark(1,0)-0.25; xmg[4]=mark(1,0)-0.25;
            ymg[0]=mark(1,1)-0.25; ymg[1]=mark(1,1)-0.25; ymg[2]=mark(1,1)+0.25; ymg[3]=mark(1,1)+0.25; ymg[4]=mark(1,1)-0.25;

            xmb[0]=mark(2,0)-0.25; xmb[1]=mark(2,0)+0.25; xmb[2]=mark(2,0)+0.25; xmb[3]=mark(2,0)-0.25; xmb[4]=mark(2,0)-0.25;
            ymb[0]=mark(2,1)-0.25; ymb[1]=mark(2,1)-0.25; ymb[2]=mark(2,1)+0.25; ymb[3]=mark(2,1)+0.25; ymb[4]=mark(2,1)-0.25;

            for (int k=0;k<5;k++){
                zmr[k]=0;
                zmg[k]=0;
                zmb[k]=0;
            }
            double cx, cy; // first robot
            double tcx, tcy; // second robot

            cx=(mp.ps(0,0)+mp.ps(0,1)+mp.ps(0,3)+mp.ps(0,2))/4;
            cy=(mp.ps(1,0)+mp.ps(1,1)+mp.ps(1,3)+mp.ps(1,2))/4;
            mp.set_cur(cx,cy);

            if (No_agent!=1){
            tcx=(mp1.ps(0,0)+mp1.ps(0,1)+mp1.ps(0,3)+mp1.ps(0,2))/4;
            tcy=(mp1.ps(1,0)+mp1.ps(1,1)+mp1.ps(1,3)+mp1.ps(1,2))/4;
            mp1.set_cur(tcx,tcy);
            }

           // cout<<ps_temp<<endl;

            for (int k=0;k<5;k++){
                x[k]=mp.p_lf(0,k);
                yy[k]=mp.p_lf(1,k);
                z[k]=mp.p_lf(2,k);

                x1[k]=mp.p_rf(0,k);
                yy1[k]=mp.p_rf(1,k);
                z1[k]=mp.p_rf(2,k);

                x2[k]=mp.p_lr(0,k);
                yy2[k]=mp.p_lr(1,k);
                z2[k]=mp.p_lr(2,k);

                x3[k]=mp.p_rr(0,k);
                yy3[k]=mp.p_rr(1,k);
                z3[k]=mp.p_rr(2,k);

            }
            for (int k=0;k<8;k++){
                x4[k]=ps_temp(0,k);
                yy4[k]=ps_temp(1,k);
                z4[k]=ps_temp(2,k);
            }


            for (int k=0;k<mp.n;k++){
                bx1[k]=(16)*k-0.5;
                by1[k]=-0.5;
                bz1[k]=0;

                bx2[k]=-0.5;
                by2[k]=(16)*k-0.5;
                bz2[k]=0;
            }

//            cout<<"z:"<<p_rf.row(2)<<endl;


            title("press r to run and stop");
            plot3(bx1,by1,bz1);
            set("k");set(3);
            plot3(bx2,by2,bz2);
            set("k");set(3); // boundary
            plot3(x,yy,z);
            set("m");set(3);
            plot3(x1,yy1,z1);
            set("c");set(3);
            plot3(x2,yy2,z2);
            set("c");set(3);
            plot3(x3,yy3,z3);
            set("m");set(3);
            plot3(x4,yy4,z4);
            set("k");set(3);

            if (No_agent!=1){

            plot3(tx,tyy,tz);
            set("m");set(3);
            plot3(tx1,tyy1,tz1);
            set("c");set(3);
            plot3(tx2,tyy2,tz2);
            set("c");set(3);
            plot3(tx3,tyy3,tz3);
            set("m");set(3);
            plot3(tx4,tyy4,tz4);
            set("k");set(3);

            }

            plot3(xmr,ymr,zmr);
            set("r");set(3);
            plot3(xmg,ymg,zmg);
            set("g");set(3);
            plot3(xmb,ymb,zmb);
            set("b");set(3);
            axis(-0.5,15.5,-0.5,15.5,0.0,5.0);
            axis(1);
            grid(0);
            //done=0;
            //done2=0;
            }
        else{
           title("press r to run and stop");
            plot3(bx1,by1,bz1);
            set("k");set(3);
            plot3(bx2,by2,bz2);
            set("k");set(3); // boundary
            plot3(x,yy,z);
            set("m");set(3);
            plot3(x1,yy1,z1);
            set("c");set(3);
            plot3(x2,yy2,z2);
            set("c");set(3);
            plot3(x3,yy3,z3);
            set("m");set(3);
            plot3(x4,yy4,z4);
            set("k");set(3);

            if (No_agent!=1){

            plot3(tx,tyy,tz);
            set("m");set(3);
            plot3(tx1,tyy1,tz1);
            set("c");set(3);
            plot3(tx2,tyy2,tz2);
            set("c");set(3);
            plot3(tx3,tyy3,tz3);
            set("m");set(3);
            plot3(tx4,tyy4,tz4);
            set("k");set(3);

            }

            plot3(xmr,ymr,zmr);
            set("r");set(3);
            plot3(xmg,ymg,zmg);
            set("g");set(3);
            plot3(xmb,ymb,zmb);
            set("b");set(3);
            axis(-0.5,15.5,-0.5,15.5,0.0,5.0);
            axis(1);
            grid(0);
        }
    } // display
}pl;



void display(){pl.display(); }
void reshape(int w,int h){ pl.reshape(w,h); }
void idle( void ){
    if(is_run)				{t+=0.02; mp.set_time(t);}
    if(is_run2 && No_agent != 1)	{t2+=0.02; mp1.set_time(t2);}
    glutPostRedisplay();
    usleep(20000);
}
void mouse(int button, int state, int x, int y ){ pl.mouse(button,state,x,y); }
void motion(int x, int y ){pl.motion(x,y); }
void passive(int x, int y ){pl.passivemotion(x,y); }

void target_dependent_init(int argc, char* argv[]){
	glutInit(&argc, argv);
	glutCreateWindow(300, 300, 1200, 900);
	generate_map();
	Matrix<double, 2, 2> data, data1;
	int path_case=0;
	data << 0.0, 0.0, 0.5, 0.0;
	data1 << 1.0, 0.0, 1.5, 0.0;
	mp.initialize(data, path_case);
	if(No_agent != 1)
		mp1.initialize(data1, path_case);
	generate_map();

	glutDisplayFunc(display);
	glutReshapeFunc(reshape);
   	glutIdleFunc( idle );
    glutMotionFunc( motion );
    glutMouseFunc( mouse );
    glutPassiveMotionFunc(passive);
    //glutKeyboardFunc( keyboard );
}


##TARGET_DEPENDENT_END