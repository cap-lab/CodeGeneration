#include <EEPROM.h>

##TARGET_DEPENDENT_INCLUDE_HEADER

#define DELAY 10
#define ARRAYLEN(ARR) (int)(sizeof(ARR)/sizeof(ARR[0]))
#define MAX_TIMER_SLOT_SIZE 10
///////////////////////////////////////////////// Common //////////////////////////////////////////////////////

##NUM_TASKS
##NUM_CHANNELS

struct TASK {
  int index;
  char* task_name;
  char* task_type; //comp, control task
  char* driven_type; //time, data, control-driven
  int period;
  unsigned long start_time;
};

static TASK tasks[] = {
##TASK_STRUCTURE
};

struct CHANNEL {
  int channel_id;
  int value;
};

static CHANNEL channels[] = {
##CHANNEL_STRUCTURE
};

struct PORTMAP {
  int task_id;
  char* port_name;
  int channel_id;
  char op;
};

static PORTMAP portmaps[] = {
##PORTMAP_STRUCTURE
};

struct PARAM {
  int task_id;
  int param_id;
  char* param_name;
  int param_value;
};

static PARAM param_list[] = {
##PARAM_STRUCTURE
};

struct CONTROL_CHANNEL {
  int control_task_id;
  unsigned int timer_status[MAX_TIMER_SLOT_SIZE];
  unsigned long timer_slot[MAX_TIMER_SLOT_SIZE];
};

static CONTROL_CHANNEL control_channel[] = {
##CONTROL_CHANNEL_STRUCTURE
};

static int init_task_port(int task_id, char* port_name){
  int i=0;
  for(i=0; i<ARRAYLEN(portmaps);i++){
     if(task_id == portmaps[i].task_id && strcmp(port_name, portmaps[i].port_name) == 0)  return portmaps[i].channel_id;
  }
  Serial.println("ERROR!!!!");
  return -1;
}

##TASK_FUNCTION_DECLARATION

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void setup()
{  
	int i;

	##TARGET_DEPENDENT_CALL_SETUP
    
    for(i=0; i<num_tasks; i++)
      tasks[i].start_time = millis();
    
##TASK_INIT_CALL
}

void loop()
{    
  int i=0;
        
  while(1)
  { 
    unsigned long cur_time = millis();
    for(i=0; i<num_tasks; i++){
		if(strcmp(tasks[i].driven_type, "TIME_DRIVEN") == 0)
	    {
	    	if(cur_time - tasks[i].start_time >= tasks[i].period){
	        	tasks[i].start_time = millis();
##TASK_GO_CALL
	      	}
      	}
    }
    
    for(i = 0; i < num_tasks; i++)
    {
      if(strcmp(tasks[i].driven_type, "DATA_DRIVEN") == 0)
      {
##TASK_GO_CALL
      }
    }       
    
  }	// while
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void sendData(int channel_id, unsigned char *data, int len)
{
  if(len == sizeof(int))	//temporarily
  {
    memcpy((unsigned char*)&channels[channel_id].value, data, len);
    //channels[channel_id].value = (int)*data;
  }
}

int receiveData(int channel_id, unsigned char *data, int len)
{
  if(len == sizeof(int))	//temporarily
  {
    memcpy(data, (unsigned char*)&channels[channel_id].value, len);
    return len;
  }
  return -1;
}

int get_task_id(char* task_name)
{
  int i;
  for(i = 0; i < num_tasks; i++)
  {
    if(strcmp(tasks[i].task_name, task_name) == 0)
      return tasks[i].index;
  }
  Serial.println("ERROR::get_task_id()");
  return -1;
}

int get_control_channel_index(unsigned int task_id)
{
  int i;
  for(i = 0; i < ARRAYLEN(control_channel); i++)
  {
    if(control_channel[i].control_task_id == task_id)
      return i;
  }
  Serial.println("ERROR::get_control_channel_index()");
  return -1;
}

void setParamInt(char* task_name, char* p_name, int p_value)
{
  int i;
  int target_task_id = get_task_id(task_name);
  
  for(i = 0; i < ARRAYLEN(param_list); i++)
  {
    if(target_task_id == param_list[i].task_id && strcmp(p_name, param_list[i].param_name) == 0)
    {
      param_list[i].param_value = p_value;
      /*Serial.print("SET :: ");
      Serial.println(p_value);
      delay(500);*/
      break;
    }
  }
}

int getParamInt(char* task_name, char* p_name)
{
  int ret = -1;
  int i;

  int target_task_id = get_task_id(task_name);
  for(i = 0; i < ARRAYLEN(param_list); i++)
  {
    if( target_task_id == param_list[i].task_id && strcmp(p_name, param_list[i].param_name) == 0)
    {
      /*Serial.print("GET :: ");
      Serial.println(param_list[i].param_value);
      delay(500);*/
      ret = param_list[i].param_value;
      break;
    }
  }

  return ret;
}

void callTask(char* t_name)
{
  int task_index = get_task_id(t_name);

##TASK_INIT_GO_WRAPUP_CALL
}

int get_valid_timer_slot_id(unsigned int control_channel_index)
{
  int i;
  for(i = 0; i < MAX_TIMER_SLOT_SIZE; i++)
  {
    if(control_channel[control_channel_index].timer_status[i] == -1)
    {
      control_channel[control_channel_index].timer_status[i] = i;
      return i;
    }
  }
  Serial.println("ERROR::get_valid_timer_slot_id():There is no space in timer_slot!");
  return -1;
}

unsigned int change_time_unit(unsigned int time_value, char *time_unit)
{
  unsigned int ret;
  if(strcmp(time_unit, "S") == 0)
  {
    ret = time_value * 1000;
  }
  else if(strcmp(time_unit, "MS") == 0)
  {
    ret = time_value;
  }
  else 
    ret = time_value;

  return ret;
}

unsigned long get_current_time_base()
{
    unsigned int time;
    time = millis();
    return time;
}

int set_timer(char* caller_task_name, unsigned int time_value, char *time_unit)
{
  int timer_id;
  unsigned int tick;
  unsigned int task_id = get_task_id(caller_task_name);
  unsigned int cont_ch_index = get_control_channel_index(task_id);

  timer_id = get_valid_timer_slot_id(cont_ch_index);

  if(timer_id != -1)
  {
    tick = change_time_unit(time_value, time_unit);

    control_channel[cont_ch_index].timer_slot[timer_id] = get_current_time_base() + tick;
  } 

  return timer_id;
}

int get_timer_alarmed(char* caller_task_name, unsigned int timer_id)
{
  unsigned int my_task_id = get_task_id(caller_task_name);
  unsigned int cont_ch_index = get_control_channel_index(my_task_id);

  unsigned int cur_time = get_current_time_base();

  if(control_channel[cont_ch_index].timer_slot[timer_id]  <= cur_time) {
    control_channel[cont_ch_index].timer_slot[timer_id]=0; // reset timer
    control_channel[cont_ch_index].timer_status[timer_id] = -1;
    return 1;
  }
  else
  {
    if((control_channel[cont_ch_index].timer_slot[timer_id] - cur_time) >= 50000000){ // overflow_case
      cur_time += 100000000;
      if(control_channel[cont_ch_index].timer_slot[timer_id]  <= cur_time) {
        control_channel[cont_ch_index].timer_slot[timer_id]=0; // reset timer
        control_channel[cont_ch_index].timer_status[timer_id] = -1;
        return 1;
      }
      else return 0;
    }
    else return 0;
  }
  return 0;

}
