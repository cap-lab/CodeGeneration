#include <Wire.h>
#include <math.h>
#include <SoftwareSerial.h>

##LIB_DATA_STRUCTURE_INCLUDE

#define RxD 6
#define TxD 7

SoftwareSerial blueToothSerial(RxD, TxD);

#define COLOR_SENSOR_ADDR  0x39//the I2C address for the color sensor 
#define EVALBOT_ADDR 0x3C

#define DELAY 10

///////////////////////////////////////////////// Common //////////////////////////////////////////////////////

##NUM_TASKS
##NUM_CHANNELS
##NUM_LIB_CHANNELS

struct TASK {
  int index;
  int period;
  unsigned long start_time;
};

static TASK tasks[] = {
##TASK_STRUCTURE
};

struct CHANNEL {
  int task_id;
  String port_name;
  int channel_id;
  char op;
};

static CHANNEL channels[] = {
##CHANNEL_STRUCTURE
};

struct LIB_CHANNEL {
  int lib_id;
  char op;
  int data_size;
};

static LIB_CHANNEL lib_channels[] = {
##LIB_CHANNEL_STRUCTURE
};

static int init_task_port(int task_id, String port_name){
  int i=0;
  for(i=0; i<num_channels;i++){
     if(task_id == channels[i].task_id && port_name ==  channels[i].port_name)  return channels[i].channel_id;
  }
  Serial.println("ERROR!!!!");
  return -1;
}

##TASK_FUNCTION_DECLARATION

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void setupBlueToothConnection()
{
  blueToothSerial.begin(38400); //Set BluetoothBee BaudRate to default baud rate 38400
  blueToothSerial.print("\r\n+STWMOD=0\r\n"); //set the bluetooth work in slave mode
  blueToothSerial.print("\r\n+STNA=SeeedBTSlave\r\n"); //set the bluetooth name as "SeeedBTSlave"
  blueToothSerial.print("\r\n+STPIN=0000\r\n");//Set SLAVE pincode"0000"
  blueToothSerial.print("\r\n+STOAUT=1\r\n"); // Permit Paired device to connect me
  blueToothSerial.print("\r\n+STAUTO=0\r\n"); // Auto-connection should be forbidden here
  delay(2000); // This delay is required.
  blueToothSerial.print("\r\n+INQ=1\r\n"); //make the slave bluetooth inquirable 
  Serial.println("The slave bluetooth is inquirable!");
  delay(2000); // This delay is required.
  blueToothSerial.flush();
}

void setup()
{  
    unsigned char isStart;
	Wire.begin(); // join i2c bus (address optional for master)
    Serial.begin(9600);
    pinMode(RxD, INPUT);
    pinMode(TxD, OUTPUT);
    setupBlueToothConnection(); 
    
    while(1){
  		isStart = readData();
 		if(isStart == 'a'){
	         Wire.beginTransmission(EVALBOT_ADDR);
	         Wire.write('z');
	         Wire.endTransmission();
	         break;
  		}
	}
    
    
##TASK_INIT_CALL
}

void loop()
{
  unsigned long recv_period = millis();
  unsigned char len = 0;
  unsigned char data[255] = {0, };
  unsigned char isData = 0;
  unsigned char chId = 0;
  int point = 0;     
  int i=0;
  
  while (blueToothSerial.available() != 0){
     char d = blueToothSerial.read(); 
  }
  
  for(i=0; i<num_tasks; i++)
    tasks[i].start_time = millis();
    
  while(1)
  { 
    unsigned long cur_time = millis();
    for(i=0; i<num_tasks; i++){
      if(cur_time - tasks[i].start_time >= tasks[i].period){
        tasks[i].start_time = millis();
##TASK_GO_CALL
      }
    }

    int isAvail = blueToothSerial.available();
    if(isAvail != 0){
        int lc_id = -1;
        while (blueToothSerial.available() == 0);
    	unsigned char lib_id = blueToothSerial.read();
    	
    	/*
    	//jhw
    	for(i=0; i<num_libchannels; i++){
    		if(lib_channels[i].lib_id == lib_id && lib_channels[i].op == 'r'){
    		    lc_id = i;
    		    break;
    		}
    	}
    	*/
    	//hshong
    	if(lib_id == 0)
    	{
    		for(i=0; i<num_libchannels; i++)
    		{
	    		if(lib_channels[i].lib_id == lib_id && lib_channels[i].op == 'r')
	    		{
	    		    lc_id = i;
	    		    break;
	    		}
    		}  	
         
	        for(i=0; i<lib_channels[lc_id].data_size; i++)	 {
	          while (blueToothSerial.available() == 0);
	          data[i] = blueToothSerial.read();
	        }
	        
	        sendLibData(lib_id, data, lib_channels[lc_id].data_size);
	        Serial.println("SendLibEnd");
    	}
    	else
    	{
    		lib_id = blueToothSerial.read();
         	Serial.print("ELSE:::: lib_id: ");
          	Serial.println(lib_id);
    	}
    } //end (if isAvail)
    
    if(cur_time - recv_period >= 500){
       recv_period = millis();
       len = 0;
       isData = readData();
       Serial.print("isData = ");
       Serial.print(isData);
       Serial.println("");
       
       if(isData != 0){
         chId = readData();
         Serial.print("ch_id= ");
         Serial.print(chId);
         Serial.println("");
         
         len = readData();
         Serial.print("len = ");
         Serial.print(len);
         Serial.println("");
         blueToothSerial.write(len);
         
         for(i=0; i<len; i++){
            data[i] = readData(); 
            blueToothSerial.write(data[i]);
         }
       }
     }
  }	// while
}

/************************************/
/* for communication with Evalbot */
/************************************/

void sendData(int channel_id, unsigned char *data, int len)
{
   Wire.beginTransmission(EVALBOT_ADDR);
   Wire.write(channel_id);
   Wire.write(len);
   Wire.write(data, len);
   Wire.endTransmission();   
}

unsigned char readData()
{
   unsigned char data;
   Wire.requestFrom(EVALBOT_ADDR, 1);
   while(Wire.available()){
     data = Wire.read();
   }
   return data;
}

void sendLibData(int library_id, unsigned char *data, int len)
{
   Wire.beginTransmission(EVALBOT_ADDR);
   Wire.write(255);	// 255: lib_data, 0~: normal_channel_data
   Wire.write(library_id);
   Wire.write(len);
   Wire.write(data, len);
   Wire.endTransmission();   
}
