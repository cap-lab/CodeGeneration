##TARGET_SPECIFIC_HANDLER_START
extern int leftMotorHandle;
extern int rightMotorHandle;
extern int cameraHandle;

//proximity sensor
extern int obstacleHandle;

##TARGET_SPECIFIC_HANDLER_END

##GET_HANDLE_MOTOR_SENSOR_START
local leftMotor=simGetObjectHandle("BubbleRobLeftMotor") --[[ Handle of the left motor ]]
local rightMotor=simGetObjectHandle("BubbleRobRightMotor") --[[ Handle of the right motor ]]
local noseSensor=simGetObjectHandle("BubbleRobSensingNose") --[[ Handle of the proximity sensor ]]
local cameraSensor=simGetObjectHandle("BubbleRobSensingCamera") --[[ Handle of the proximity sensor ]]
##GET_HANDLE_MOTOR_SENSOR_END

##REMOTE_API_START_W_PORT_START
for i = 0, 2, 1 do --[[for(i = 0 ; i <= 2(=CLIENT_NUM-1); i++)]]
		simExtRemoteApiStart(portNb + (i*1000))
	end
##REMOTE_API_START_W_PORT_END

##LAUNCH_CLIENT_APP_START
result=simLaunchExecutable('proc',portNb.." "..leftMotor.." "..rightMotor.." "..noseSensor.." "..cameraSensor,0) 
	-- set the last argument to 1 to see the console of the launched client
##LAUNCH_CLIENT_APP_END

##DISPLAY_ERROR_MESSAGE_START
simDisplayDialog('Error',"'proc' could not be launched. &&nSimulation will not run properly",sim_dlgstyle_ok,true,nil,{0.8,0,0,0,0,0},{0.5,0,0,1,1,1})
##DISPLAY_ERROR_MESSAGE_END

##TARGET_DEPENDENT_SPECIFIC_INCLUDE_START
int leftMotorHandle;
int rightMotorHandle;
int obstacleHandle;
int cameraHandle;
float motorSpeeds[2];	//for API
##TARGET_DEPENDENT_SPECIFIC_INCLUDE_END

##TARGET_DEPENDENT_SPECIFIC_DEFINE_NUM_START
#define TARGET_PARAM_NUM 6
#define CLIENT_NUM 3
//0: motor, 1: obstacle, 2: camera
#define CLIENT_MOTOR 0
#define CLIENT_OBSTACLE 1
#define CLIENT_CAMERA 2
##TARGET_DEPENDENT_SPECIFIC_DEFINE_NUM_END

##TARGET_DEPENDENT_SPECIFIC_INIT_IMPLEMENTATION_START
	int i;
    int portNb = 0;
    if (argc>= TARGET_PARAM_NUM)
    {
        portNb=atoi(argv[1]);
		leftMotorHandle=atoi(argv[2]);
		rightMotorHandle=atoi(argv[3]);
		obstacleHandle=atoi(argv[4]);
		cameraHandle=atoi(argv[5]);
    }
    else
    {
        printf("Indicate following arguments: 'portNumber leftMotorHandle rightMotorHandle sensorHandle'!\n");
        extApi_sleepMs(5000);
        return 0;
    }
	
	for(i = 0; i < CLIENT_NUM; i++)
	{
		clientID[i]=simxStart((simxChar*)"127.0.0.1", portNb+(i*1000) ,true,true,2000,5);
	}
    
	for(i = 0 ; i < CLIENT_NUM; i++)
	{
		if(clientID[i] != -1)
	    {
	        printf("[[simxStart Success!!::ID: %d]]\n", clientID[i]);
	    }
	    else
	    {
	    	printf("[[simxStart FAIL!!::ID: %d]]\n", clientID[i]);
	    	sleep(10000);
	    }	    
	}	
##TARGET_DEPENDENT_SPECIFIC_INIT_IMPLEMENTATION_END

##TARGET_DEPENDENT_SPECIFIC_API_GO_IMPLEMENTATION_START
	if(clientID[CLIENT_MOTOR] != -1)
	{
		//printf("move::clientID[CLIENT_MOTOR] is OK\n");
		if(simxGetConnectionId(clientID[CLIENT_MOTOR]) != -1)
		{
			//printf("move::getConnectionID is OK\n");
			motorSpeeds[0]=3.1415f;
			motorSpeeds[1]=3.1415f;
			simxSetJointTargetVelocity(clientID[CLIENT_MOTOR],leftMotorHandle,motorSpeeds[0],simx_opmode_oneshot);            
			simxSetJointTargetVelocity(clientID[CLIENT_MOTOR],rightMotorHandle,motorSpeeds[1],simx_opmode_oneshot);
		}
	}	
	else
		printf("client ID[CLIENT_MOTOR] is WRONG!\n");				
##TARGET_DEPENDENT_SPECIFIC_API_GO_IMPLEMENTATION_END

##TARGET_DEPENDENT_SPECIFIC_API_STOP_IMPLEMENTATION_START
if(clientID[CLIENT_MOTOR] != -1)
	{
		//printf("move::clientID[CLIENT_MOTOR] is OK\n");
		if(simxGetConnectionId(clientID[CLIENT_MOTOR]) != -1)
		{
			//printf("move::getConnectionID is OK\n");
			motorSpeeds[0]=0;
			motorSpeeds[1]=0;
			simxSetJointTargetVelocity(clientID[CLIENT_MOTOR],leftMotorHandle,motorSpeeds[0],simx_opmode_oneshot);            
			simxSetJointTargetVelocity(clientID[CLIENT_MOTOR],rightMotorHandle,motorSpeeds[1],simx_opmode_oneshot);
		}
	}	
	else
		printf("client ID[CLIENT_MOTOR] is WRONG!\n");				
##TARGET_DEPENDENT_SPECIFIC_API_STOP_IMPLEMENTATION_END

##TARGET_DEPENDENT_SPECIFIC_API_GOBACK_IMPLEMENTATION_START
if(clientID[CLIENT_MOTOR] != -1)
	{
		//printf("move::clientID[CLIENT_MOTOR] is OK\n");
		if(simxGetConnectionId(clientID[CLIENT_MOTOR]) != -1)
		{
			//printf("move::getConnectionID is OK\n");
			motorSpeeds[0]=-3.1415f;
			motorSpeeds[1]=-3.1415f;
			simxSetJointTargetVelocity(clientID[CLIENT_MOTOR],leftMotorHandle,motorSpeeds[0],simx_opmode_oneshot);            
			simxSetJointTargetVelocity(clientID[CLIENT_MOTOR],rightMotorHandle,motorSpeeds[1],simx_opmode_oneshot);
		}
	}	
	else
		printf("client ID[CLIENT_MOTOR] is WRONG!\n");				
##TARGET_DEPENDENT_SPECIFIC_API_GOBACK_IMPLEMENTATION_END

##TARGET_DEPENDENT_SPECIFIC_API_TURN_IMPLEMENTATION_START
if(clientID[CLIENT_MOTOR] != -1)
	{
		//printf("move::clientID[CLIENT_MOTOR] is OK\n");
		if(simxGetConnectionId(clientID[CLIENT_MOTOR]) != -1)
		{
			//printf("move::getConnectionID is OK\n");
			if(direction == 0)	//left
			{
				motorSpeeds[0]= -3.1415f;
				motorSpeeds[1]= 3.1415f;
			}
			else if(direction == 1) //right
			{
				motorSpeeds[0]= 3.1415f;
				motorSpeeds[1]= -3.1415f;
			}
			simxSetJointTargetVelocity(clientID[CLIENT_MOTOR],leftMotorHandle,motorSpeeds[0],simx_opmode_oneshot);            
			simxSetJointTargetVelocity(clientID[CLIENT_MOTOR],rightMotorHandle,motorSpeeds[1],simx_opmode_oneshot);
			
			extApi_sleepMs(1500 * (angle/45));	//6000 = 45 degree? // need to tuning   
			
			motorSpeeds[0]=0;
			motorSpeeds[1]=0;
			simxSetJointTargetVelocity(clientID[CLIENT_MOTOR],leftMotorHandle,motorSpeeds[0],simx_opmode_oneshot);            
			simxSetJointTargetVelocity(clientID[CLIENT_MOTOR],rightMotorHandle,motorSpeeds[1],simx_opmode_oneshot);
		}
	}	
	else
		printf("client ID[CLIENT_MOTOR] is WRONG!\n");						
##TARGET_DEPENDENT_SPECIFIC_API_TURN_IMPLEMENTATION_END

##TARGET_DEPENDENT_SPECIFIC_API_MEET_OBSTACLE_IMPLEMENTATION_START
	if (clientID[CLIENT_OBSTACLE]!=-1)
    {
        if(simxGetConnectionId(clientID[CLIENT_OBSTACLE])!=-1)
        {
            // TODO: task main code
		    simxUChar sensorTrigger=0;    //1: sensorTrigger, 0: not Trigger
		    
		    if(simxReadProximitySensor(clientID[CLIENT_OBSTACLE], obstacleHandle, &sensorTrigger, NULL, NULL, NULL, simx_opmode_streaming)==simx_return_ok)
            {
		        extApi_sleepMs(30);		        
                return (int)sensorTrigger;
            }
            else
            {
                printf("Distance::-----read Proximity Sensor FAILED!!\n");
                extApi_sleepMs(100);
                return 0;
            }
        }
        else
        {
            printf("Distance::[ERROR] can not get connection id!!\n");
            return 0;
        }
    }   
    else
    {
        printf("Distance::[ERROR] cleintID[CLIENT_OBSTACLE] == -1\n");
        return 0;
    }
##TARGET_DEPENDENT_SPECIFIC_API_MEET_OBSTACLE_IMPLEMENTATION_END
