##INIT_WRAPUP_WRAPPER_LIBRARY_CHANNELS_START
static void init_lib_channel(void)
{
    unsigned int i;

    shm_id = shmget((key_t)KEY_NUM, sizeof(LIB_CHANNEL)*2*1, IPC_CREAT|0666);
    if(shm_id == -1)
    {
    	printf("Fail to get SHM!\n");
    	exit(1);
    }

    shm_memory = shmat(shm_id, (void*)0, 0);
    if(shm_memory == (void*) -1)
    {
    	printf("Fail to attach SHM!\n");
    	exit(1);
    }

    printf("success SHM attached!\n");

##LIB_CHANNEL_MAP_SHM_MEMORY    
    lib_channels[0] = (LIB_CHANNEL*)shm_memory;
    lib_channels[1] = (LIB_CHANNEL*)(shm_memory + sizeof(LIB_CHANNEL));

    for(i = 0; i < num_libchannels; i++)
    {
    	MUTEX_INIT(&(lib_channels[i]->mutex));
        COND_INIT(&(lib_channels[i]->cond));
                
    	memset(lib_channels[i]->buf, 0, sizeof(lib_channels[i]->buf));
        
        lib_channels[i]->start = 0; 
 		lib_channels[i]->end = 0; 
 		lib_channels[i]->cur_size =0;
 		lib_channels[i]->isFull = 0;

##LIBCHANNEL_ENTRIES
    	lib_channels[i]->channel_id = 0;
    	strncpy(lib_channels[i]->lib_name, "GlobalState", strlen("GlobalState"));
 		if((i%2) == 0)
 		{
 			lib_channels[i]->op = 'r'; 			
 			lib_channels[i]->max_size = sizeof(GlobalState_func_data);
 			lib_channels[i]->sampleSize = sizeof(GlobalState_func_data);
 		}
 		else
 		{
 			lib_channels[i]->op = 'w';
 			lib_channels[i]->max_size = sizeof(GlobalState_ret_data);
 			lib_channels[i]->sampleSize = sizeof(GlobalState_ret_data);
 		} 		

 		lib_channels[i]->canIStart = 25;
    }   
}

static void wrapup_lib_channel(void)
{
    unsigned int i;

    while(1)
    {
    	if(shmctl(shm_id, IPC_STAT, &shm_info) == -1)
    	{
    		printf("Fail to get SHM info!\n");
    		exit(1);
    	}

    	if(shm_info.shm_nattch == 1)
    		break;
    	else
    	{
    		printf("waiting...... \n");
    		sleep(1);
    	}
    }

    if(shmdt(shm_memory) == -1)
    {
    	printf("Fail to detach SHM!\n");
    	exit(1);
    }

    if(shmctl(shm_id, IPC_RMID, 0) == -1)
    {
    	printf("Fail to delete SHM!\n");
    	exit(1);
    }
    else
    	printf("Success to delete SHM!\n");
}
##INIT_WRAPUP_WRAPPER_LIBRARY_CHANNELS_END

##INIT_WRAPUP_STUB_LIBRARY_CHANNELS_START
void init_lib_channel(void)
{
    unsigned int i;

    shm_id = shmget((key_t)KEY_NUM, sizeof(LIB_CHANNEL)*2*1, IPC_CREAT|0666);
    if(shm_id == -1)
    {
    	printf("Fail to get SHM!\n");
    	exit(1);
    }

    shm_memory = shmat(shm_id, (void*)0, 0);
    if(shm_memory == (void*) -1)
    {
    	printf("Fail to attach SHM!\n");
    	exit(1);
    }

    printf("success SHM attached!\n");
##LIB_CHANNEL_MAP_SHM_MEMORY
    lib_channels[0] = (LIB_CHANNEL*)shm_memory;
    lib_channels[1] = (LIB_CHANNEL*)(shm_memory + sizeof(LIB_CHANNEL));

    printf("111111111 i'm caller\n");

    while(1)
    {
        int result = 0; 

        for(i = 0; i < num_libchannels; i++)
        {
            result += lib_channels[i]->canIStart;
        }

        if(result == 50)
            break;
        else
        {  
            printf("i'm caller: waiting for set up..... %d\n", result);
            fflush(stdout);
            sleep(1);
        }
    }


    printf("######CALLER################# FINISHED init_lib_channel!\n");
    fflush(stdout);
}


void wrapup_lib_channel(void)
{
    unsigned int i;
 
    if(shmdt(shm_memory) == -1)
    {
    	printf("Fail to detach SHM!\n");
    	exit(1);
    }
    else
        printf("Success to datach SHM!: i'm caller\n");
    
}
##INIT_WRAPUP_STUB_LIBRARY_CHANNELS_END

##READ_WRITE_LIB_PORT_START
int init_lib_port(int library_id, const char op)
{
    unsigned int i;
    for(i=0; i<num_libchannels; i++)
    {
        if(lib_channels[i]->channel_id == library_id && lib_channels[i]->op == op)
        {
            return i;
        }
    }

    printf("Warning : init_lib_port(): No port is available or connected\n");
    return -1;
}

int read_lib_port(int channel_index, unsigned char *buf, int len)
{
    int cur_size=0;
    //LIB_CHANNEL *channel = (LIB_CHANNEL* )lib_channels[channel_index];

read_lib_start:
    MUTEX_LOCK(&(lib_channels[channel_index]->mutex));
    if(lib_channels[channel_index]->start < lib_channels[channel_index]->end)  
        cur_size = (lib_channels[channel_index]->end - lib_channels[channel_index]->start);
    else if(lib_channels[channel_index]->start == lib_channels[channel_index]->end)
    {
      if(lib_channels[channel_index]->isFull == 0)      
        cur_size = 0;
      else if(lib_channels[channel_index]->isFull == 1) 
        cur_size = lib_channels[channel_index]->max_size;
    }
    else  cur_size = lib_channels[channel_index]->end + lib_channels[channel_index]->max_size - lib_channels[channel_index]->start;

    if(len > cur_size) // blocking case
    {
        COND_WAIT(&(lib_channels[channel_index]->cond), &(lib_channels[channel_index]->mutex));
        MUTEX_UNLOCK(&(lib_channels[channel_index]->mutex));
        //printf("$$$ LIBRARY $$$ i'm blocking in read_lib_port\n");
        
		//
        if(shmctl(shm_id, IPC_STAT, &shm_info) == -1)
    	{
    		printf("Fail to get SHM info!\n");
    		exit(1);
    	}

    	if(shm_info.shm_nattch == 1)
    		return 0;
        //

        goto read_lib_start; // try reading again
    }

    if(lib_channels[channel_index]->start + len <= lib_channels[channel_index]->max_size)   //이부분 바뀌어야함 
    {
        memcpy(buf, &lib_channels[channel_index]->buf[lib_channels[channel_index]->start], len);
        lib_channels[channel_index]->start += len;
    }
    else
    {
        int part = lib_channels[channel_index]->max_size - lib_channels[channel_index]->start;  //이부분 바뀌어야함 
        if(part != 0)
        {
            memcpy(buf, &lib_channels[channel_index]->buf[lib_channels[channel_index]->start], part);
        }
        memcpy(buf + part, lib_channels[channel_index]->buf, len - part);
        lib_channels[channel_index]->start = len - part;//lib_channels[channel_index]->buf + (len - part);
    }
    
    if(lib_channels[channel_index]->end == lib_channels[channel_index]->start)  lib_channels[channel_index]->isFull = 0;

    MUTEX_UNLOCK(&(lib_channels[channel_index]->mutex));
    COND_BROADCAST(&(lib_channels[channel_index]->cond));

    return len;
}

int write_lib_port(int channel_index, unsigned char *buf, int len)
{
    int cur_size=0;
    //LIB_CHANNEL *channel = lib_channels[channel_index];

write_lib_start:
    MUTEX_LOCK(&(lib_channels[channel_index]->mutex));
    if(lib_channels[channel_index]->start < lib_channels[channel_index]->end)  
        cur_size = (unsigned int)(lib_channels[channel_index]->end - lib_channels[channel_index]->start);
    else if(lib_channels[channel_index]->start == lib_channels[channel_index]->end)
    {
      if(lib_channels[channel_index]->isFull == 0)       
        cur_size = 0;
      else if(lib_channels[channel_index]->isFull == 1)  
        cur_size = lib_channels[channel_index]->max_size;
    }
    else   
        cur_size = (unsigned int)(lib_channels[channel_index]->end + lib_channels[channel_index]->max_size - lib_channels[channel_index]->start);

    if(len + cur_size > lib_channels[channel_index]->max_size || lib_channels[channel_index]->isFull == 1) // blocking case    //if(len + cur_size >= channel->max_size)
    {
        COND_WAIT(&(lib_channels[channel_index]->cond), &(lib_channels[channel_index]->mutex));
        MUTEX_UNLOCK(&(lib_channels[channel_index]->mutex));        
        //printf("$$$ LIBRARY $$$ i'm blocking in wrt_lib_port\n");
        //sleep(1);   //추가했음! 
        goto write_lib_start; // try writing again
    }  

    if(lib_channels[channel_index]->max_size >= lib_channels[channel_index]->end + len) //이부분 바뀌어야함 //1st
    {      
        memcpy(&lib_channels[channel_index]->buf[lib_channels[channel_index]->end], buf, len);
        lib_channels[channel_index]->end += len;
    }
    else
    {
        int part = lib_channels[channel_index]->max_size - lib_channels[channel_index]->end;    //channel 기준 뒷부분 조각 크기   //이부분 바뀌어야함 
        if(part != 0)
        {
            memcpy(&lib_channels[channel_index]->buf[lib_channels[channel_index]->end], buf, part);
        }
        memcpy(lib_channels[channel_index]->buf, buf + part, len - part);    
        lib_channels[channel_index]->end = len - part; //lib_channels[channel_index]->buf + (len - part);
    }
    
    if(lib_channels[channel_index]->end == lib_channels[channel_index]->start)  lib_channels[channel_index]->isFull = 1;
    
    MUTEX_UNLOCK(&(lib_channels[channel_index]->mutex));
    COND_BROADCAST(&(lib_channels[channel_index]->cond));

    return len;
}

int lib_available(int channel_index) // non-blocking
{
    int ret;

    LIB_CHANNEL *channel = (LIB_CHANNEL*)&lib_channels[channel_index];

    MUTEX_LOCK(&(channel->mutex));

    if(channel->start <= channel->end) {
    	ret = (unsigned int)(channel->end - channel->start);
    	if(ret == 0 && channel->isFull == true)	ret = channel->max_size;
    }
    else  	ret = (unsigned int)(channel->end + channel->max_size - channel->start);

    MUTEX_UNLOCK(&(channel->mutex));

    return ret;
}
##READ_WRITE_LIB_PORT_END