##TARGET_SPECIFIC_INCLUDE_HEADER_START
//#include "target_library.h"
#include <eigen3/Eigen/Dense>
#include <eigen3/Eigen/Geometry>
#include <eigen3/Eigen/LU>

using namespace Eigen;
using namespace std;

#define PI std::atan(1.0)*4
##TARGET_SPECIFIC_INCLUDE_HEADER_END

##TARGET_SPECIFIC_HANDLER_START
extern int BodyHandle;
extern int LegHandle;
extern int LegTipsHandle[4];
extern int LegTargetsHandle[4];

extern int cameraHandle;

//proximity sensor
extern int obstacleHandle;

##TARGET_SPECIFIC_HANDLER_END

##GET_HANDLE_MOTOR_SENSOR_START
local BodyBase=simGetObjectHandle("rw_base") 
local LegBase=simGetObjectHandle("rw_legbase") 
local LegTips0=simGetObjectHandle("rw_footTip0")
local LegTips1=simGetObjectHandle("rw_footTip1")
local LegTips2=simGetObjectHandle("rw_footTip2") 
local LegTips3=simGetObjectHandle("rw_footTip3")
local LegTargets0=simGetObjectHandle("rw_footTarget0") 
local LegTargets1=simGetObjectHandle("rw_footTarget1") 
local LegTargets2=simGetObjectHandle("rw_footTarget2") 
local LegTargets3=simGetObjectHandle("rw_footTarget3") 

local noseSensor=simGetObjectHandle("QuadrupedSensingNose") --[[ Handle of the proximity sensor ]]
local cameraSensor=simGetObjectHandle("QuadrupedSensingCamera") --[[ Handle of the proximity sensor ]]
##GET_HANDLE_MOTOR_SENSOR_END

##REMOTE_API_START_W_PORT_START
for i = 0, 2, 1 do --[[for(i = 0 ; i <= 2(=CLIENT_NUM-1); i++)]]
		simExtRemoteApiStart(portNb + (i*1000))
	end
##REMOTE_API_START_W_PORT_END

##LAUNCH_CLIENT_APP_START
result=simLaunchExecutable('proc',portNb.." "..BodyBase.." "..LegBase.." "..LegTips0.." "..LegTips1.." "..LegTips2.." "..LegTips3.." "..LegTargets0.." "..LegTargets1.." "..LegTargets2.." "..LegTargets3.." "..noseSensor.." "..cameraSensor, 0) 
	-- set the last argument to 1 to see the console of the launched client
##LAUNCH_CLIENT_APP_END

##DISPLAY_ERROR_MESSAGE_START
simDisplayDialog('Error',"'proc' could not be launched. &&nSimulation will not run properly",sim_dlgstyle_ok,true,nil,{0.8,0,0,0,0,0},{0.5,0,0,1,1,1})
##DISPLAY_ERROR_MESSAGE_END

##TARGET_DEPENDENT_SPECIFIC_INCLUDE_START
int BodyHandle;
int LegHandle;
int LegTipsHandle[4];
int LegTargetsHandle[4];

int obstacleHandle;
int cameraHandle;

Matrix<int, 6, 4> order; //for API
float Pos[3];			//for API
float Posreset[12];		//for API
float yscale;			//for API
##TARGET_DEPENDENT_SPECIFIC_INCLUDE_END

##TARGET_DEPENDENT_SPECIFIC_DEFINE_NUM_START
#define TARGET_PARAM_NUM 13
#define CLIENT_NUM 3
//0: leg, 1: obstacle, 2: camera
#define CLIENT_MOTOR 0
#define CLIENT_OBSTACLE 1
#define CLIENT_CAMERA 2
##TARGET_DEPENDENT_SPECIFIC_DEFINE_NUM_END

##TARGET_DEPENDENT_SPECIFIC_INIT_IMPLEMENTATION_START
	int i;
    int portNb = 0;
    
    order.row(0)<<3,2,1,0;
	order.row(1)<<2,0,3,1;
	order.row(2)<<0,1,2,3;
	order.row(3)<<1,3,0,2;

	order.row(4)<<3,2,0,1;
	order.row(5)<<2,3,1,0;
	
    if (argc>= TARGET_PARAM_NUM)
    {
        portNb=atoi(argv[1]);
		BodyHandle=atoi(argv[2]);
		LegHandle=atoi(argv[3]);
		LegTipsHandle[0]=atoi(argv[4]);
		LegTipsHandle[1]=atoi(argv[5]);
		LegTipsHandle[2]=atoi(argv[6]);
		LegTipsHandle[3]=atoi(argv[7]);
		LegTargetsHandle[0]=atoi(argv[8]);
		LegTargetsHandle[1]=atoi(argv[9]);
		LegTargetsHandle[2]=atoi(argv[10]);
		LegTargetsHandle[3]=atoi(argv[11]);
		obstacleHandle=atoi(argv[12]);
		cameraHandle=atoi(argv[13]);
    }
    else
    {
        printf("Indicate following arguments: 'portNumber portNumber BodyHandle BodyHandle sensorHandle cameraHandle'!\n");
        extApi_sleepMs(5000);
        return 0;
    }
	
	for(i = 0; i < CLIENT_NUM; i++)
	{
		clientID[i]=simxStart((simxChar*)"127.0.0.1", portNb+(i*1000) ,true,true,2000,5);
	}
    
	for(i = 0 ; i < CLIENT_NUM; i++)
	{
		if(clientID[i] != -1)
	    {
	        printf("[[simxStart Success!!::ID: %d]]\n", clientID[i]);
	    }
	    else
	    {
	    	printf("[[simxStart FAIL!!::ID: %d]]\n", clientID[i]);
	    	sleep(10000);
	    }	    
	}	
##TARGET_DEPENDENT_SPECIFIC_INIT_IMPLEMENTATION_END

##TARGET_DEPENDENT_SPECIFIC_IMPLEMENTATION_START
void actuateLegs(int motioncase)
{
	int side = motioncase % 2;
    int forwrd = floor( motioncase / 2);

    float Posstack[12];
    float dang = PI/6*pow(-1,motioncase);
    float step = 0.1*pow(-1,forwrd);
    float h = -0.03;

    float n = 2;	//go straight/back height divider
    float m = 4;	//turn divider
    
    if (motioncase<4)
    {
        for (int iter=0;iter<5;iter++)
        {
            for (int i=0;i<12;i++){
                Posstack[i]=Posreset[i];
            }
            for (int j=0;j<4;j++)
            {	
            	// leg up
                for (int swingstep=0;swingstep<n;swingstep++)	
                {	
                    for(int k=0;k<4;k++)
                    {
                        if (k==order(motioncase,j))
                        {
                            //cout<<"from:"<<Posstack[3*k]<<","<<Posstack[3*k+1]<<","<<Posstack[3*k+2]<<"----swing:"<<k<<endl;
                            Posstack[3*k+side]=Posstack[3*k+side]+3*step/8/n;
                            Posstack[3*k+2]=Posstack[3*k+2]-h/n;
                            Pos[0]=Posstack[3*k];
                            Pos[1]=Posstack[3*k+1];
                            Pos[2]=Posstack[3*k+2];
                            //cout<<"to  :"<<Posstack[3*k]<<","<<Posstack[3*k+1]<<","<<Posstack[3*k+2]<<endl;
                            simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
                        }
                        else
                        {
                            //cout<<"from:"<<Posstack[3*k]<<","<<Posstack[3*k+1]<<","<<Posstack[3*k+2]<<"---------:"<<k<<endl;
                            Posstack[3*k+side]=Posstack[3*k+side]-step/8/n;
                            Pos[0]=Posstack[3*k];
                            Pos[1]=Posstack[3*k+1];
                            Pos[2]=Posstack[3*k+2];
                            //cout<<"to  :"<<Posstack[3*k]<<","<<Posstack[3*k+1]<<","<<Posstack[3*k+2]<<endl;
                            simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
                        }
                    }
                }
                //leg down
                for (int swingstep=0;swingstep<2;swingstep++)
                {
                    for(int k=0;k<4;k++)
                    {
                        if (k==order(motioncase,j))
                        {
                            Posstack[3*k+side]=Posstack[3*k+side]+3*step/8/n;
                            Posstack[3*k+2]=Posstack[3*k+2]+h/n;
                            Pos[0]=Posstack[3*k];
                            Pos[1]=Posstack[3*k+1];
                            Pos[2]=Posstack[3*k+2];
                            simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
                        }
                        else
                        {
                            Posstack[3*k+side]=Posstack[3*k+side]-step/8/n;
                            Pos[0]=Posstack[3*k];
                            Pos[1]=Posstack[3*k+1];
                            Pos[2]=Posstack[3*k+2];
                            simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
                        }
                    }
                }
            }
        }
    } //end of "if (motioncase<4)"
 
}

void actuateLegs(int motioncase, int angleUnit, int angleCount)
{
	int side = motioncase % 2;
    int forwrd = floor( motioncase / 2);

    float Posstack[12];
    float dang = PI/angleUnit*pow(-1,motioncase);
    float step = 0.1*pow(-1,forwrd);
    float h = -0.03;

    float n = 2;	//go straight/back height divider
    float m = 4;	//turn divider
            
    if( motioncase >= 4 )
    {
    	for (int iter = 0; iter < angleCount; iter++)
	    {
	        for (int i=0;i<12;i++){
	            Posstack[i]=Posreset[i];
	        }
	        for (int j=0;j<4;j++)
	        {
	        	//leg up
	            for (int swingstep=0;swingstep<m;swingstep++)
	            {
	                for(int k=0;k<4;k++)
	                {
	                    if (k==order(motioncase,j))
	                    {
	                        Posstack[3*k]=Posstack[3*k]*cos(dang*3/8/m)-sin(dang*3/8/m)*(Posstack[3*k+1]-yscale);
	                        Posstack[3*k+1]=Posstack[3*k]*sin(dang*3/8/m)+cos(dang*3/8/m)*(Posstack[3*k+1]-yscale)+yscale;
	                        Posstack[3*k+2]=Posstack[3*k+2]-h/m;
	                        Pos[0]=Posstack[3*k];
	                        Pos[1]=Posstack[3*k+1];
	                        Pos[2]=Posstack[3*k+2];
	                        simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
	                    }
	                    else
	                    {
	                        Posstack[3*k]=cos(-dang/8/m)*Posstack[3*k]-sin(-dang/8/m)*(Posstack[3*k+1]-yscale);
	                        Posstack[3*k+1]=sin(-dang/8/m)*Posstack[3*k]+cos(-dang/8/m)*(Posstack[3*k+1]-yscale)+yscale;
	                        Pos[0]=Posstack[3*k];
	                        Pos[1]=Posstack[3*k+1];
	                        Pos[2]=Posstack[3*k+2];
	                        simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
	                    }
	                }
	            }
	            //leg down
	            for (int swingstep=0;swingstep<3;swingstep++)
	            {
	                for(int k=0;k<4;k++)
	                {
	                    if (k==order(motioncase,j))
	                    {
	                        Posstack[3*k]=cos(dang*3/8/m)*Posstack[3*k]-sin(dang*3/8/m)*(Posstack[3*k+1]-yscale);
	                        Posstack[3*k+1]=sin(dang*3/8/m)*Posstack[3*k]+cos(dang*3/8/m)*(Posstack[3*k+1]-yscale)+yscale;
	                        Posstack[3*k+2]=Posstack[3*k+2]+h/m;
	                        Pos[0]=Posstack[3*k];
	                        Pos[1]=Posstack[3*k+1];
	                        Pos[2]=Posstack[3*k+2];
	                        simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
	                    }
	                    else
	                    {
	                        Posstack[3*k]=cos(-dang/8/m)*Posstack[3*k]-sin(-dang/8/m)*(Posstack[3*k+1]-yscale);
	                        Posstack[3*k+1]=sin(-dang/8/m)*Posstack[3*k]+cos(-dang/8/m)*(Posstack[3*k+1]-yscale)+yscale;
	                        Pos[0]=Posstack[3*k];
	                        Pos[1]=Posstack[3*k+1];
	                        Pos[2]=Posstack[3*k+2];
	                        simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
	                    }
	                }
	            }
	        }
	    }
    }    //end of "if (motioncase >= 4)"
}
/*
void actuateLegs(int motioncase)
{
	int side = motioncase % 2;
    int forwrd = floor( motioncase / 2);

    float Posstack[12];
    float dang = PI/6*pow(-1,motioncase);
    float step = 0.1*pow(-1,forwrd);
    float h = -0.03;

    float n = 2;	//go straight/back height divider
    float m = 4;	//turn divider
    
    if (motioncase<4)
    {
        for (int iter=0;iter<5;iter++)
        {
            for (int i=0;i<12;i++){
                Posstack[i]=Posreset[i];
            }
            for (int j=0;j<4;j++)
            {	
            	// leg up
                for (int swingstep=0;swingstep<n;swingstep++)	
                {	
                    for(int k=0;k<4;k++)
                    {
                        if (k==order(motioncase,j))
                        {
                            //cout<<"from:"<<Posstack[3*k]<<","<<Posstack[3*k+1]<<","<<Posstack[3*k+2]<<"----swing:"<<k<<endl;
                            Posstack[3*k+side]=Posstack[3*k+side]+3*step/8/n;
                            Posstack[3*k+2]=Posstack[3*k+2]-h/n;
                            Pos[0]=Posstack[3*k];
                            Pos[1]=Posstack[3*k+1];
                            Pos[2]=Posstack[3*k+2];
                            //cout<<"to  :"<<Posstack[3*k]<<","<<Posstack[3*k+1]<<","<<Posstack[3*k+2]<<endl;
                            simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
                        }
                        else
                        {
                            //cout<<"from:"<<Posstack[3*k]<<","<<Posstack[3*k+1]<<","<<Posstack[3*k+2]<<"---------:"<<k<<endl;
                            Posstack[3*k+side]=Posstack[3*k+side]-step/8/n;
                            Pos[0]=Posstack[3*k];
                            Pos[1]=Posstack[3*k+1];
                            Pos[2]=Posstack[3*k+2];
                            //cout<<"to  :"<<Posstack[3*k]<<","<<Posstack[3*k+1]<<","<<Posstack[3*k+2]<<endl;
                            simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
                        }
                    }
                }
                //leg down
                for (int swingstep=0;swingstep<2;swingstep++)
                {
                    for(int k=0;k<4;k++)
                    {
                        if (k==order(motioncase,j))
                        {
                            Posstack[3*k+side]=Posstack[3*k+side]+3*step/8/n;
                            Posstack[3*k+2]=Posstack[3*k+2]+h/n;
                            Pos[0]=Posstack[3*k];
                            Pos[1]=Posstack[3*k+1];
                            Pos[2]=Posstack[3*k+2];
                            simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
                        }
                        else
                        {
                            Posstack[3*k+side]=Posstack[3*k+side]-step/8/n;
                            Pos[0]=Posstack[3*k];
                            Pos[1]=Posstack[3*k+1];
                            Pos[2]=Posstack[3*k+2];
                            simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
                        }
                    }
                }
            }
        }
    } //end of "if (motioncase<4)"
    else	// turn
    {
        for (int iter=0;iter<3;iter++)
        {
            for (int i=0;i<12;i++){
                Posstack[i]=Posreset[i];
            }
            for (int j=0;j<4;j++)
            {
            	//leg up
                for (int swingstep=0;swingstep<m;swingstep++)
                {
                    for(int k=0;k<4;k++)
                    {
                        if (k==order(motioncase,j))
                        {
                            Posstack[3*k]=Posstack[3*k]*cos(dang*3/8/m)-sin(dang*3/8/m)*(Posstack[3*k+1]-yscale);
                            Posstack[3*k+1]=Posstack[3*k]*sin(dang*3/8/m)+cos(dang*3/8/m)*(Posstack[3*k+1]-yscale)+yscale;
                            Posstack[3*k+2]=Posstack[3*k+2]-h/m;
                            Pos[0]=Posstack[3*k];
                            Pos[1]=Posstack[3*k+1];
                            Pos[2]=Posstack[3*k+2];
                            simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
                        }
                        else
                        {
                            Posstack[3*k]=cos(-dang/8/m)*Posstack[3*k]-sin(-dang/8/m)*(Posstack[3*k+1]-yscale);
                            Posstack[3*k+1]=sin(-dang/8/m)*Posstack[3*k]+cos(-dang/8/m)*(Posstack[3*k+1]-yscale)+yscale;
                            Pos[0]=Posstack[3*k];
                            Pos[1]=Posstack[3*k+1];
                            Pos[2]=Posstack[3*k+2];
                            simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
                        }
                    }
                }
                //leg down
                for (int swingstep=0;swingstep<3;swingstep++)
                {
                    for(int k=0;k<4;k++)
                    {
                        if (k==order(motioncase,j))
                        {
                            Posstack[3*k]=cos(dang*3/8/m)*Posstack[3*k]-sin(dang*3/8/m)*(Posstack[3*k+1]-yscale);
                            Posstack[3*k+1]=sin(dang*3/8/m)*Posstack[3*k]+cos(dang*3/8/m)*(Posstack[3*k+1]-yscale)+yscale;
                            Posstack[3*k+2]=Posstack[3*k+2]+h/m;
                            Pos[0]=Posstack[3*k];
                            Pos[1]=Posstack[3*k+1];
                            Pos[2]=Posstack[3*k+2];
                            simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
                        }
                        else
                        {
                            Posstack[3*k]=cos(-dang/8/m)*Posstack[3*k]-sin(-dang/8/m)*(Posstack[3*k+1]-yscale);
                            Posstack[3*k+1]=sin(-dang/8/m)*Posstack[3*k]+cos(-dang/8/m)*(Posstack[3*k+1]-yscale)+yscale;
                            Pos[0]=Posstack[3*k];
                            Pos[1]=Posstack[3*k+1];
                            Pos[2]=Posstack[3*k+2];
                            simxSetObjectPosition(clientID[CLIENT_MOTOR],LegTargetsHandle[k],LegHandle,Pos,simx_opmode_oneshot_wait);
                        }
                    }
                }
            }
        }
    } //end of "else if (motioncase>=4)"
}
*/
##TARGET_DEPENDENT_SPECIFIC_IMPLEMENTATION_END

##TARGET_DEPENDENT_SPECIFIC_API_GO_IMPLEMENTATION_START
	if(clientID[CLIENT_MOTOR] != -1)
	{		
		for (int i=0;i<4;i++)
		{		
            simxGetObjectPosition(clientID[CLIENT_MOTOR],LegTipsHandle[i],LegHandle,Pos,simx_opmode_oneshot_wait);
            Posreset[3*i]=Pos[0];
            Posreset[3*i+1]=Pos[1];
            Posreset[3*i+2]=Pos[2];
        }
        yscale=-(abs(Posreset[1])+abs(Posreset[7]))/2;
		
		//printf("move::clientID[CLIENT_MOTOR] is OK\n");
		if(simxGetConnectionId(clientID[CLIENT_MOTOR]) != -1)
		{
			int motioncase = 1; // forward 
			actuateLegs(motioncase);       
		}
	}	
	else
		printf("client ID[CLIENT_MOTOR] is WRONG!\n");				
##TARGET_DEPENDENT_SPECIFIC_API_GO_IMPLEMENTATION_END

##TARGET_DEPENDENT_SPECIFIC_API_STOP_IMPLEMENTATION_START
	if(clientID[CLIENT_MOTOR] != -1)
	{
		//printf("move::clientID[CLIENT_MOTOR] is OK\n");
		if(simxGetConnectionId(clientID[CLIENT_MOTOR]) != -1)
		{
			;
			// do nothing
		}
	}	
	else
		printf("client ID[CLIENT_MOTOR] is WRONG!\n");				
##TARGET_DEPENDENT_SPECIFIC_API_STOP_IMPLEMENTATION_END

##TARGET_DEPENDENT_SPECIFIC_API_GOBACK_IMPLEMENTATION_START
	if(clientID[CLIENT_MOTOR] != -1)
	{		
		for (int i=0;i<4;i++)
		{		
            simxGetObjectPosition(clientID[CLIENT_MOTOR],LegTipsHandle[i],LegHandle,Pos,simx_opmode_oneshot_wait);
            Posreset[3*i]=Pos[0];
            Posreset[3*i+1]=Pos[1];
            Posreset[3*i+2]=Pos[2];
        }
        yscale=-(abs(Posreset[1])+abs(Posreset[7]))/2;
		
		//printf("move::clientID[CLIENT_MOTOR] is OK\n");
		if(simxGetConnectionId(clientID[CLIENT_MOTOR]) != -1)
		{
			int motioncase = 3; // backward 
			actuateLegs(motioncase);       
		}
	}	
	else
		printf("client ID[CLIENT_MOTOR] is WRONG!\n");		
##TARGET_DEPENDENT_SPECIFIC_API_GOBACK_IMPLEMENTATION_END

##TARGET_DEPENDENT_SPECIFIC_API_TURN_IMPLEMENTATION_START
	if(clientID[CLIENT_MOTOR] != -1)
	{		
		for (int i=0;i<4;i++)
		{		
            simxGetObjectPosition(clientID[CLIENT_MOTOR],LegTipsHandle[i],LegHandle,Pos,simx_opmode_oneshot_wait);
            Posreset[3*i]=Pos[0];
            Posreset[3*i+1]=Pos[1];
            Posreset[3*i+2]=Pos[2];
        }
        yscale=-(abs(Posreset[1])+abs(Posreset[7]))/2;
		
		//printf("move::clientID[CLIENT_MOTOR] is OK\n");
		if(simxGetConnectionId(clientID[CLIENT_MOTOR]) != -1)
		{
			int motioncase;
			if(direction == 0) //left
				motioncase = 4; // counter-clock-wise
			else if(direction == 1) // right
				motioncase = 5; //clock-wise
			
			int angleUnit;
			int angleCount; 
			
			//we assume 45 degree is unit and also supported only 30 degree
			if(angle == 30)
			{
				angleUnit = 9;
				angleCount = 2;
			}
			else if(angle == 60)
			{
				angleUnit = 9;
				angleCount = 4;
			}
			else
			{
				angleUnit = 6;
				angleCount = (angle/45);
			}
						 
			actuateLegs(motioncase, angleUnit, angleCount);       
		}
	}	
	else
		printf("client ID[CLIENT_MOTOR] is WRONG!\n");					
##TARGET_DEPENDENT_SPECIFIC_API_TURN_IMPLEMENTATION_END

##TARGET_DEPENDENT_SPECIFIC_API_MEET_OBSTACLE_IMPLEMENTATION_START
	if (clientID[CLIENT_OBSTACLE]!=-1)
    {
        if(simxGetConnectionId(clientID[CLIENT_OBSTACLE])!=-1)
        {
            // TODO: task main code
		    simxUChar sensorTrigger=0;    //1: sensorTrigger, 0: not Trigger
		    
		    if(simxReadProximitySensor(clientID[CLIENT_OBSTACLE], obstacleHandle, &sensorTrigger, NULL, NULL, NULL, simx_opmode_streaming)==simx_return_ok)
            {
		        extApi_sleepMs(30);		        
                return (int)sensorTrigger;
            }
            else
            {
                printf("Distance::-----read Proximity Sensor FAILED!!\n");
                extApi_sleepMs(100);
                return 0;
            }
        }
        else
        {
            printf("Distance::[ERROR] can not get connection id!!\n");
            return 0;
        }
    }   
    else
    {
        printf("Distance::[ERROR] cleintID[CLIENT_OBSTACLE] == -1\n");
        return 0;
    }
##TARGET_DEPENDENT_SPECIFIC_API_MEET_OBSTACLE_IMPLEMENTATION_END

