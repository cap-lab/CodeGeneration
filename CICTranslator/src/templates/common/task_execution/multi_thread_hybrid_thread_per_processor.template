##TASK_VARIABLE_DECLARATION_START
// For thread synchonization
#if defined(SYSTEM_THREAD_SUPPORT) && (SYSTEM_THREAD_SUPPORT==1) 
CIC_VOLATILE CIC_STATIC CIC_T_BOOL channel_empty = CIC_V_FALSE;

CIC_STATIC CIC_T_MUTEX global_mutex;
CIC_STATIC CIC_T_COND global_cond;

CIC_STATIC CIC_T_INT control_thread_count;
CIC_STATIC CIC_T_BARRIER control_task_barrier;
CIC_STATIC CIC_T_BOOL exit_signal = CIC_V_FALSE;
#endif
##TASK_VARIABLE_DECLARATION_END


##TASK_ROUTINE_START
CIC_STATIC CIC_T_VOID CheckGraphEnd(CIC_T_INT parent_task_id){
	CIC_T_INT i, j;
	CIC_T_INT parent_task_index = GetTaskIndexForId(parent_task_id);
	CIC_T_INT task_count = 0, complete_count = 0;
    for(i=0; i<CIC_UV_NUM_VIRTUAL_TASKS; i++){
    	if(virtual_tasks[i].parent_task_id == parent_task_id){
			if(tasks[parent_task_index].state == STATE_END && 
				tasks[parent_task_index].run_count <= virtual_tasks[i].run_count){
				complete_count++;
    		}
			task_count++;
    	}
    }
    
    CIC_F_MUTEX_LOCK(&global_mutex);
    if(task_count == complete_count && tasks[parent_task_index].state != STATE_STOP){
		CIC_T_THREAD cur_thread = CIC_F_THREAD_SELF();
    
    	if(tasks[parent_task_index].has_subgraph){
    		for(j=0; j<CIC_UV_NUM_VIRTUAL_TASKS; j++){
    			if(virtual_tasks[j].parent_task_id == parent_task_id){
    				virtual_tasks[j].state = STATE_STOP;
    				virtual_tasks[j].run_count = 0;
    				if(!CIC_F_THREAD_EQUAL(cur_thread, virtual_tasks[j].thread)){
    					CIC_F_THREAD_CANCEL(virtual_tasks[j].thread);
    				}
    			}
    		}
    		WrapupTaskChannels(parent_task_id);
    	}
    	else{
    		CIC_F_THREAD_CANCEL(tasks[i].thread);
    		tasks[parent_task_index].Wrapup();
    	}
       
       
        tasks[parent_task_index].state = STATE_STOP;   
        tasks[parent_task_index].run_count = 0;
        CIC_F_PRINTF("End graph %s (task_id: %d)\n", tasks[parent_task_index].name, tasks[parent_task_index].task_id);
        CIC_F_COND_BROADCAST(&global_cond);
	}
	CIC_F_MUTEX_UNLOCK(&global_mutex);
}

CIC_UT_THREAD_FUNC_RET_TYPE VirtualTaskRoutine(CIC_UT_THREAD_FUNC_ARG_TYPE pdata)
{
    CIC_T_INT task_id = *((CIC_T_INT*)&pdata);
    CIC_T_INT task_index = task_id - CIC_UV_NUM_TASKS;
   	CIC_T_INT parent_task_id = virtual_tasks[task_index].parent_task_id;
   	CIC_T_INT parent_task_index = GetTaskIndexForId(parent_task_id);
   	CIC_T_INT mtm_index = -1;
	CIC_T_INT i=0;
	
##SET_VIRTUAL_PROC

	if(tasks[parent_task_index].has_mtm == CIC_V_TRUE){
		mtm_index = GetMTMIndexForTaskId(parent_task_id);
	}

	(*virtual_tasks[task_index].Init)(task_index);

virtual_task_continue:
    while(CIC_V_TRUE) {
        if(tasks[parent_task_index].state == STATE_WAIT){
            CIC_F_MUTEX_LOCK(&(virtual_tasks[task_index].mutex));
            CIC_F_COND_WAIT(&(virtual_tasks[task_index].cond), &(virtual_tasks[task_index].mutex));
            CIC_F_MUTEX_UNLOCK(&(virtual_tasks[task_index].mutex));
        }
        
		if(exit_signal)    break;
		
        // Call TASK_GO function of a task
   		(*virtual_tasks[task_index].Go)();
        
        virtual_tasks[task_index].run_count += 1;
        
        if(tasks[parent_task_index].state == STATE_END && 
			tasks[parent_task_index].run_count <= virtual_tasks[task_index].run_count){
			break;	
		}
    }
    
	(*virtual_tasks[task_index].Wrapup)();
	
    virtual_tasks[task_index].state = STATE_STOP;
    CheckGraphEnd(parent_task_id);
	
    return CIC_V_NULL;
}

CIC_UT_THREAD_FUNC_RET_TYPE TaskRoutine(CIC_UT_THREAD_FUNC_ARG_TYPE pdata)
{
	CIC_T_INT task_id = *((CIC_T_INT*)&pdata);
	CIC_T_INT task_index = GetTaskIndexForId(task_id);
	CIC_T_INT proc_id = 0;
	CIC_T_CHAR* mode_name = "Default";
	
	if(tasks[task_index].period <= 0)	return CIC_V_NULL;
	
##SET_PROC

	if(*tasks[task_index].PreInit != CIC_V_NULL) TASK_PREINIT;
	TASK_INIT;

	if(tasks[task_index].task_type == CONTROL){
		CIC_F_BARRIER_WAIT(&control_task_barrier);	// When TASK_INIT functions of control tasks are called,
	}
	
task_continue:   
	while(CIC_V_TRUE){
		if(tasks[task_index].state == STATE_WAIT){
            CIC_F_MUTEX_LOCK(&(tasks[task_index].mutex));
            CIC_F_COND_WAIT(&(tasks[task_index].cond), &(tasks[task_index].mutex));
            CIC_F_MUTEX_UNLOCK(&(tasks[task_index].mutex));
        }
        
        if(tasks[task_index].has_mtm == CIC_V_TRUE){
            CIC_T_INT mtm_index = GetMTMIndexForTaskId(task_id);
            mtms[mtm_index].Transition();
        }
	
		if(*tasks[task_index].PreGo != CIC_V_NULL) TASK_PREGO;
		TASK_GO;
		if(*tasks[task_index].PostGo != CIC_V_NULL) TASK_POSTGO;

        if(exit_signal || tasks[task_index].state == STATE_STOP)    break;
	}
		 
	TASK_WRAPUP;
	if(*tasks[task_index].PostWrapup != CIC_V_NULL) TASK_POSTWRAPUP;
	CIC_F_MUTEX_LOCK(&global_mutex);
	tasks[task_index].state = STATE_STOP;
	CIC_F_COND_BROADCAST(&global_cond);
    CIC_F_MUTEX_UNLOCK(&global_mutex);
}
##TASK_ROUTINE_END

##EXECUTE_TASKS_START
CIC_STATIC CIC_T_VOID ExecuteTasks(CIC_T_VOID)
{
	CIC_T_INT i=0;

    CIC_F_PRINT_STRING("\n------ Task thread create information ------\n");
    
    // Call MTM initialize function
    for(i=0; i<CIC_UV_NUM_MTMS; i++){
    	mtms[i].Initialize();
    }
      
    // Control barrier initialize
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
   		if(tasks[i].task_type == CONTROL){
    		control_thread_count++;
    	}
    }
    CIC_F_BARRIER_INIT(&control_task_barrier, control_thread_count+1);	// +1 is for itself
       
    // Create threads for control tasks 
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(tasks[i].task_type == CONTROL){
	        CIC_F_PRINTF("%s task thread (Control) is created!\n", tasks[i].name);
			CIC_F_THREAD_CREATE(&(tasks[i].thread), TaskRoutine, (CIC_T_VOID *)tasks[i].task_id);
		}
    }
     
    // Wait until TASK_INIT functions of all control tasks are called
    CIC_F_BARRIER_WAIT(&control_task_barrier);
      
      
	// Create threads for computational tasks
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(tasks[i].task_type != CONTROL){
	        CIC_T_BOOL create_thread = CIC_V_FALSE;

	        if(tasks[i].parent_task_id == i && !tasks[i].has_subgraph)    create_thread = CIC_V_TRUE;
            else                                						  create_thread = CIC_V_FALSE;

	        if(create_thread == CIC_V_TRUE && tasks[i].state == STATE_RUN){
	            CIC_F_PRINTF("%s task thread is created!\n", tasks[i].name);
	            CIC_F_THREAD_CREATE(&(tasks[i].thread), TaskRoutine, (void *)tasks[i].task_id);
			}
	    }
    }
    
    for(i=0; i<CIC_UV_NUM_VIRTUAL_TASKS; i++){
        CIC_T_BOOL create_thread = CIC_V_FALSE;
		CIC_T_INT parent_task_index = GetTaskIndexForId(virtual_tasks[i].parent_task_id);
        if(tasks[parent_task_index].state == STATE_RUN){
            CIC_F_PRINTF("%s virtual_task thread is created!\n", virtual_tasks[i].name);
            CIC_F_THREAD_CREATE(&(virtual_tasks[i].thread), VirtualTaskRoutine, (void *)virtual_tasks[i].task_id);
		}
    }
    CIC_F_PRINT_STRING("--------------------------------------------\n");
    
    // Tasks are Running
	while(CIC_V_TRUE){
		CIC_T_BOOL end_flag = CIC_V_TRUE;
		CIC_F_MUTEX_LOCK(&global_mutex);
		CIC_F_COND_WAIT(&global_cond, &global_mutex);
		for(i=0; i<CIC_UV_NUM_TASKS; i++){
			if(!tasks[i].is_child_task && tasks[i].state != STATE_STOP){
				end_flag = CIC_V_FALSE;
				break;
			}
		}
		CIC_F_MUTEX_UNLOCK(&global_mutex);
		if(end_flag)	break;
	}

    for(i=0; i<CIC_UV_NUM_TASKS; i++)
        if(tasks[i].thread != CIC_V_NULL)	CIC_F_THREAD_CANCEL(tasks[i].thread);
        
    for(i=0; i<CIC_UV_NUM_VIRTUAL_TASKS; i++)
        if(virtual_tasks[i].thread != CIC_V_NULL)	CIC_F_THREAD_CANCEL(virtual_tasks[i].thread);
    
	return;
}
##EXECUTE_TASKS_END

##CONTROL_RUN_TASK_START
    CIC_T_INT i=0, j=0;
    CIC_T_INT target_task_id = GetTaskIdForName(t_name);
    CIC_T_INT target_task_index = GetTaskIndexForName(t_name);
    
    if(tasks[target_task_index].has_mtm){
    	CIC_T_INT mtm_index = GetMTMIndexForTaskId(target_task_id);
		mtms[mtm_index].Initialize();
	}
    
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(target_task_id == tasks[i].task_id){
        	if(tasks[i].has_subgraph){
        		InitTaskChannels(target_task_id);
        		for(j=0; j<CIC_UV_NUM_VIRTUAL_TASKS; j++){
        			if(virtual_tasks[j].parent_task_id == target_task_id){
        				virtual_tasks[j].state = STATE_RUN;
        				virtual_tasks[j].run_count = 0;
        				CIC_F_THREAD_CREATE(&(virtual_tasks[j].thread), VirtualTaskRoutine, (void *)virtual_tasks[j].task_id);
        			}
        		}
        	}
        	else{
        		 CIC_F_THREAD_CREATE(&(tasks[i].thread), TaskRoutine, (void *)tasks[i].task_id);
        	}
           
            tasks[i].state = STATE_RUN;
	        tasks[i].run_count = 0;
	        CIC_F_PRINTF("Run task %s (task_id: %d)\n", tasks[i].name, tasks[i].task_id);
	        break;
        }
    }  
##CONTROL_RUN_TASK_END

##CONTROL_STOP_TASK_START
 	CIC_T_INT i=0, j=0;
    CIC_T_INT target_task_id = GetTaskIdForName(t_name);
    CIC_T_THREAD cur_thread = CIC_F_THREAD_SELF();
    
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(target_task_id == tasks[i].task_id){
        	if(tasks[i].has_subgraph){
        		for(j=0; j<CIC_UV_NUM_VIRTUAL_TASKS; j++){
        			if(virtual_tasks[j].parent_task_id == target_task_id){
        				virtual_tasks[j].state = STATE_STOP;
        				virtual_tasks[j].run_count = 0;
        				if(!CIC_F_THREAD_EQUAL(cur_thread, virtual_tasks[j].thread)){
        					CIC_F_THREAD_CANCEL(virtual_tasks[j].thread);
        				}
        			}
        		}
        		WrapupTaskChannels(target_task_id);
        	}
        	else{
        		CIC_F_THREAD_CANCEL(tasks[i].thread);
        	}
           
            CIC_F_MUTEX_LOCK(&global_mutex);
            tasks[i].state = STATE_STOP;
	        tasks[i].run_count = 0;
	        CIC_F_PRINTF("Stop task %s (task_id: %d)\n", tasks[i].name, tasks[i].task_id);
	        CIC_F_COND_BROADCAST(&global_cond);
    		CIC_F_MUTEX_UNLOCK(&global_mutex);
	        break;
        }
    }  

    return;
##CONTROL_STOP_TASK_END

##CONTROL_RESUME_TASK_START
 	CIC_T_INT i=0, j=0;
    CIC_T_INT target_task_id = GetTaskIdForName(t_name);
    
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(target_task_id == tasks[i].task_id){
        	if(tasks[i].has_subgraph){
        		if(tasks[i].state != STATE_STOP)	tasks[i].state = STATE_RUN;
        		for(j=0; j<CIC_UV_NUM_VIRTUAL_TASKS; j++){
        			if(virtual_tasks[j].parent_task_id == target_task_id){
        				if(virtual_tasks[j].state != STATE_STOP){
        					virtual_tasks[j].state = STATE_RUN;
        					CIC_F_COND_BROADCAST(&(virtual_tasks[j].cond));
        				}
        			}
        		}	
        	}
        	else{
        		if(tasks[i].state != STATE_STOP){
        			tasks[i].state = STATE_RUN;
        			CIC_F_COND_BROADCAST(&(tasks[i].cond));
        		}
        	}
        	CIC_F_PRINTF("Resume task %s(task_id: %d)\n", tasks[i].name, tasks[i].task_id);
	        break;
        }
    } 
    
    return;
##CONTROL_RESUME_TASK_END

##CONTROL_SUSPEND_TASK_START
 	CIC_T_INT i=0, j=0;
    CIC_T_INT target_task_id = GetTaskIdForName(t_name);
    
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(target_task_id == tasks[i].task_id){
        	if(tasks[i].has_subgraph){
        		for(j=0; j<CIC_UV_NUM_VIRTUAL_TASKS; j++){
        			if(virtual_tasks[j].parent_task_id == target_task_id){
        				if(virtual_tasks[j].state != STATE_STOP)	 virtual_tasks[j].state = STATE_WAIT;
        			}
        		}
        		if(tasks[i].state != STATE_STOP)	tasks[i].state = STATE_WAIT;
        	}
        	else{
        		if(tasks[i].state != STATE_STOP)	tasks[i].state = STATE_WAIT;
        	}
            CIC_F_PRINTF("Suspend task %s(task_id: %d)\n", tasks[i].name, tasks[i].task_id);
	        break;
        }
    } 

    return;
##CONTROL_SUSPEND_TASK_END

##CONTROL_END_TASK_START
    CIC_T_INT i=0;
    CIC_T_INT run_count=0;
    CIC_T_THREAD th = CIC_F_THREAD_SELF();
    CIC_T_INT task_index = 0;
    
    CIC_T_INT target_task_id = GetTaskIdForName(t_name);
    CIC_T_INT target_task_index = GetTaskIndexForName(t_name);
    
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
		if(target_task_id == tasks[i].task_id){
			if(tasks[i].has_subgraph){
				for(i=0; i<CIC_UV_NUM_VIRTUAL_TASKS; i++){
					if(CIC_F_THREAD_EQUAL(virtual_tasks[i].thread, th)){
						task_index = i;
						break;
					}

				}

				tasks[target_task_index].state = STATE_END;
				tasks[target_task_index].run_count = virtual_tasks[task_index].run_count;

				(*virtual_tasks[task_index].Wrapup)();

				virtual_tasks[task_index].state = STATE_STOP;
				CheckGraphEnd(target_task_index);
			}
			else{
				CIC_F_MUTEX_LOCK(&global_mutex);
				tasks[target_task_index].state = STATE_STOP;
				CIC_F_COND_BROADCAST(&global_cond);
    			CIC_F_MUTEX_UNLOCK(&global_mutex);
			}
			break;
		}
	}

	CIC_F_PRINTF("End task %s (task_id: %d)\n", tasks[target_task_index].name, tasks[target_task_index].task_id);
    CIC_F_THREAD_EXIT();
   
    return;
##CONTROL_END_TASK_END
