##VARIABLE_DECLARATION_START
// For thread synchonization
#if defined(SYSTEM_THREAD_SUPPORT) && (SYSTEM_THREAD_SUPPORT==1) 
CIC_VOLATILE CIC_STATIC CIC_T_BOOLEAN all_threads_created = CIC_V_CIC_V_FALSE;
CIC_VOLATILE CIC_STATIC CIC_T_BOOLEAN channel_empty = CIC_V_CIC_V_FALSE;
CIC_VOLATILE CIC_STATIC CIC_T_INT time_task_count = 0;
CIC_STATIC CIC_T_INT num_time_task = 0;
CIC_VOLATILE CIC_STATIC CIC_T_BOOLEAN global_sync = CIC_V_FALSE;

CIC_STATIC CIC_T_MUTEX time_mutex;
CIC_STATIC CIC_T_COND time_cond;
CIC_STATIC CIC_T_MUTEX global_mutex;
CIC_STATIC CIC_T_COND global_cond;
CIC_STATIC CIC_T_BARRIER control_task_barrier;
CIC_STATIC CIC_T_BARRIER all_thread_barrier;
#endif
##VARIABLE_DECLARATION_END

##DATA_TASK_ROUTINE_START
THREAD_FUNC_RET_TYPE data_task_routine(THREAD_FUNC_ARG_TYPE pdata)
{
	//int task_index = (int)pdata;
	int task_index = *((int*)&pdata);

	if(tasks[task_index].task_type != Control){
		while(!all_threads_created) {
			SCHED_YIELD();
		}
	}

##SET_PROC

	if(*tasks[task_index].preinit != NULL) TASK_PREINIT;
	TASK_INIT;

	if(tasks[task_index].task_type == Control){
		MUTEX_LOCK(&control_task_count_lock);
		control_task_count++;
		if(control_task_count == control_task_total_count)	all_control_tasks_initiated = true;
		MUTEX_UNLOCK(&control_task_count_lock);
	}

	while(true) {
		if(tasks[task_index].state == Wait){
            MUTEX_LOCK(&(tasks[task_index].p_mutex));
            COND_WAIT(&(tasks[task_index].p_cond), &(tasks[task_index].p_mutex));
            MUTEX_UNLOCK(&(tasks[task_index].p_mutex));
        }
        if(global_sync){
            MUTEX_LOCK(&(global_mutex));
            COND_WAIT(&(global_cond), &(global_mutex));
            MUTEX_UNLOCK(&(global_mutex));
        }
        
		if(tasks[task_index].hasMTM == true){
            int i=0;
            for(i=0; i<num_mtms; i++)
                if(task_index == mtms[i].task_id)  break;
            mtms[i].transition();
        }

        if(*tasks[task_index].prego != NULL) TASK_PREGO;
		TASK_GO;
		if(*tasks[task_index].postgo != NULL) TASK_POSTGO;
		
		if(channel_empty)	tasks[task_index].run_state = None;
 
        if(exit_signal == 1 || tasks[task_index].state == Stop)    break;
	}

	TASK_WRAPUP;
	if(*tasks[task_index].postwrapup != NULL) TASK_POSTWRAPUP;
	tasks[task_index].state = Stop;

}
##DATA_TASK_ROUTINE_END

##TIME_TASK_ROUTINE_START
THREAD_FUNC_RET_TYPE time_task_routine(THREAD_FUNC_ARG_TYPE pdata)
{
    //int task_index = (int)pdata;
    int task_index = *((int*)&pdata);
    
    unsigned int period = tasks[task_index].period;
    unsigned int current, end;

    if(tasks[task_index].period <= 0)       return NULL;

    if(tasks[task_index].task_type != Control){
            while(!all_threads_created) {
                    SCHED_YIELD();
            }
    }

##SET_PROC

    if(*tasks[task_index].preinit != NULL) TASK_PREINIT;
    TASK_INIT;

    if(tasks[task_index].task_type == Control){
            MUTEX_LOCK(&control_task_count_lock);
            control_task_count++;
            if(control_task_count == control_task_total_count)      all_control_tasks_initiated = true;
            MUTEX_UNLOCK(&control_task_count_lock);
    }

task_continue:
    if(tasks[task_index].p_metric == S)             period = period * 1000;
    else if(tasks[task_index].p_metric == MS)       period = period * 1000;
    else if(tasks[task_index].p_metric == US)       period = period;

    while(1){
            end = get_current_time_base();
            end += period;
            if(tasks[task_index].state == Wait){
                    MUTEX_LOCK(&(tasks[task_index].p_mutex));
                    COND_WAIT(&(tasks[task_index].p_cond), &(tasks[task_index].p_mutex));
                    MUTEX_UNLOCK(&(tasks[task_index].p_mutex));
            }
            if(global_sync){
                    MUTEX_LOCK(&(global_mutex));
                    COND_WAIT(&(global_cond), &(global_mutex));
                    MUTEX_UNLOCK(&(global_mutex));
            }

            if(tasks[task_index].hasMTM == true){
                    int i=0;
                    for(i=0; i<num_mtms; i++)
                            if(task_index == mtms[i].task_id)  break;
                    mtms[i].transition();
            }

            if(*tasks[task_index].prego != NULL) TASK_PREGO;
            TASK_GO;
            if(*tasks[task_index].postgo != NULL) TASK_POSTGO;

            while(1){
                    current = get_current_time_base();
                    if(current >= end)       		      break;
                    else if(abs(current-end) >= period)      break;
                    else                    usleep(1000);
            }

            if(exit_signal == 1 || tasks[task_index].state == Stop)    break;
    }

    MUTEX_LOCK(&time_mutex);
    time_task_count++;
    COND_WAIT(&time_cond, &time_mutex);
#if defined(RESUME) && (RESUME==1)
    if(resume == true){
            MUTEX_UNLOCK(&time_mutex);
            goto task_continue;
    }
#endif
    MUTEX_UNLOCK(&time_mutex);

    TASK_WRAPUP;
    if(*tasks[task_index].postwrapup != NULL) TASK_POSTWRAPUP;
    tasks[task_index].state = Stop;
}
##TIME_TASK_ROUTINE_END

##EXECUTE_TASKS_START
#ifdef LIB_WRAPPER
THREAD_FUNC_RET_TYPE lib_wrapper_routine(THREAD_FUNC_ARG_TYPE pdata){
    int wrapper_index = (int)pdata;

    lib_wrappers[wrapper_index].init();
    lib_wrappers[wrapper_index].go();
    lib_wrappers[wrapper_index].wrapup();
}
#endif

static void execute_tasks(void)
{
	int i=0;

    printf("\n------ Task thread create information ------\n");
    for(i=0; i<num_tasks; i++)
    {
        if(tasks[i].task_type == Control){
            control_task_total_count++;
	        printf("%s task thread (Control) is created!\n", tasks[i].name);

		    if(tasks[i].driven_type == TimeDriven){
	            THREAD_CREATE(&(tasks[i].thread), time_task_routine, (void *)tasks[i].task_id);
	            num_time_task++;
	        }
	        else if(tasks[i].driven_type == DataDriven || tasks[i].driven_type == ControlDriven ){
	            THREAD_CREATE(&(tasks[i].thread), data_task_routine, (void *)tasks[i].task_id);
	        }
	        else
	            continue;
		}
    }
    
#ifdef LIB_WRAPPER
    for(i=0; i<num_libwrappers; i++){
     	 printf("%s lib wrapper thread is created!\n", lib_wrappers[i].name);
         THREAD_CREATE(&(lib_wrappers[i].th), lib_wrapper_routine, (void *)i);
    }
#endif
    
    if(control_task_total_count != 0)
		while(!all_control_tasks_initiated) {}

    for(i=0; i<num_tasks; i++)
    {
        if(tasks[i].task_type != Control){
	        int create_thread = 0;

	        if(tasks[i].parent_task_id == i)    create_thread = 1;
            else                                create_thread = 0;

	        if(create_thread == 1 && tasks[i].state == Run){
	            printf("%s task thread is created!\n", tasks[i].name);

		        if(tasks[i].driven_type == TimeDriven){
                    THREAD_CREATE(&(tasks[i].thread), time_task_routine, (void *)tasks[i].task_id);
		            num_time_task++;
		        }
		        else if(tasks[i].driven_type == DataDriven || tasks[i].driven_type == ControlDriven ){
		            THREAD_CREATE(&(tasks[i].thread), data_task_routine, (void *)tasks[i].task_id);
		        }
		        else
		            continue;
			}
	    }
    }
    
    printf("--------------------------------------------\n");
    
    all_threads_created = true;
    
    // Tasks are Running
go_continue:
	while(1){
		fflush(stdout);
		if(time_task_count == num_time_task){
			wait_data_tasks_end();
#if defined(RESUME) && (RESUME==1)
			fflush(stdout);
			SLEEP(1); 
			resume = wait_from_gui_resume();
			if(resume == true){
				COND_BROADCAST(&time_cond);
				time_task_count = 0;
				channel_empty = false;
				goto go_continue;
			}
			else{
				COND_BROADCAST(&time_cond);
				break;
			}
#else
			COND_BROADCAST(&time_cond);
			break;
#endif
		}
	}

    for(i=0; i<num_tasks; i++)
    {
        THREAD_CANCEL(tasks[i].thread);
    }

	return;
}
##EXECUTE_TASKS_END

##CONTROL_RUN_TASK_START
    int i=0;
    int target_task_id = get_task_id(t_name);
    for(i=0; i<ARRAYLEN(tasks); i++)
    {
        if(target_task_id == tasks[i].task_id)
        {
            int task_id = tasks[i].task_id;
	        
	        init_task_channel(task_id);
	        
	        if(tasks[task_id].driven_type == DataDriven || tasks[task_id].driven_type == ControlDriven )
	            THREAD_CREATE(&(tasks[task_id].thread), data_task_routine, (void *)task_id);
	        else if(tasks[task_id].driven_type == TimeDriven)
	            THREAD_CREATE(&(tasks[task_id].thread), time_task_routine, (void *)task_id);
	            
	        tasks[task_id].state = Run;
	        PRINT("Run task %s (task_id: %d)\n", tasks[task_id].name, task_id);
	        break;
        }
    }  
##CONTROL_RUN_TASK_END

##CONTROL_STOP_TASK_START
    int i=0;
    if(STRING_COMPARE(caller_task_name, t_name) == 0){
    	int task_id = get_task_id(caller_task_name);
    	int parent_task_id = tasks[task_id].parent_task_id;
        THREAD_CANCEL(tasks[parent_task_id].thread);
        wrapup_task_channel(parent_task_id);
        tasks[parent_task_id].state = Stop;
        PRINT("Stop a task (own)");
    }
    else{
      int target_task_id = get_task_id(t_name);
      for(i=0; i<ARRAYLEN(tasks); i++)
      {
          if(target_task_id == tasks[i].task_id)
          {
               int task_id = tasks[i].task_id;
	            THREAD_CANCEL(tasks[task_id].thread);
	            wrapup_task_channel(task_id);
	            tasks[task_id].state = Stop;
	            PRINT("Stop task %s (task_id: %d)\n", tasks[task_id].name, task_id);
	            break;
          }
      } 
    }

    return;
##CONTROL_STOP_TASK_END

##CONTROL_RESUME_TASK_START
    int i=0;
    
    int target_task_id = get_task_id(t_name);
    for(i=0; i<ARRAYLEN(tasks); i++)
    {
        if(target_task_id == tasks[i].task_id)
        {
            int task_id = tasks[i].task_id;
            if(tasks[task_id].state != Stop)	tasks[task_id].state = Run;
            COND_BROADCAST(&(tasks[task_id].p_cond));
            PRINT("Resume task %s(task_id: %d)\n", tasks[task_id].name, task_id);
            break;
        }
    } 
    return;
##CONTROL_RESUME_TASK_END

##CONTROL_SUSPEND_TASK_START
    int i=0;
    
    if(STRING_COMPARE(caller_task_name, t_name) == 0){
        int task_id = get_task_id(caller_task_name);
        int parent_task_id = tasks[task_id].parent_task_id;
        if(tasks[parent_task_id].state != Stop)	tasks[parent_task_id].state = Wait;
        PRINT("Suspend a task (own)");
    }
    else{
      int target_task_id = get_task_id(t_name);
      for(i=0; i<ARRAYLEN(tasks); i++)
      {
          if(target_task_id == tasks[i].task_id)
          {
              int task_id = tasks[i].task_id;
              if(tasks[task_id].state != Stop)	 tasks[task_id].state = Wait;
              PRINT("Suspend task %s(task_id: %d)\n", tasks[task_id].name, task_id);
              break;
          }
      }  

    }
    return;
##CONTROL_SUSPEND_TASK_END
