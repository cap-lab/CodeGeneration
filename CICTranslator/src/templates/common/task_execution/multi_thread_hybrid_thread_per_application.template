##TASK_VARIABLE_DECLARATION_START
// For thread synchonization
#if defined(SYSTEM_THREAD_SUPPORT) && (SYSTEM_THREAD_SUPPORT==1) 
CIC_VOLATILE CIC_STATIC CIC_T_BOOL channel_empty = CIC_V_FALSE;

CIC_STATIC CIC_T_MUTEX time_mutex;
CIC_STATIC CIC_T_COND time_cond;
CIC_STATIC CIC_T_INT num_time_task = 0;
CIC_VOLATILE CIC_STATIC CIC_T_INT time_task_count = 0;

CIC_STATIC CIC_T_MUTEX global_mutex;
CIC_STATIC CIC_T_COND global_cond;
CIC_VOLATILE CIC_STATIC CIC_T_BOOL global_sync = CIC_V_FALSE;

CIC_STATIC CIC_T_INT all_thread_count;
CIC_STATIC CIC_T_BARRIER all_thread_barrier;
CIC_VOLATILE CIC_STATIC CIC_T_BOOL all_thread_barrier_initialized = CIC_V_FALSE;

CIC_STATIC CIC_T_INT control_thread_count;
CIC_STATIC CIC_T_BARRIER control_task_barrier;
CIC_STATIC CIC_T_BOOL exit_signal = CIC_V_FALSE;
#endif
##TASK_VARIABLE_DECLARATION_END


##TASK_ROUTINE_START
CIC_UT_THREAD_FUNC_RET_TYPE VirtualTaskRoutine(CIC_UT_THREAD_FUNC_ARG_TYPE pdata)
{
    CIC_T_INT task_id = *((CIC_T_INT*)&pdata);
    CIC_T_INT task_index = task_id - CIC_UV_NUM_TASKS;
    CIC_T_INT iteration_count = virtual_tasks[task_index].run_count;
	CIC_T_INT count = 0;

##SET_PROC

	CIC_F_BARRIER_WAIT(&all_thread_barrier);

	(*virtual_tasks[task_index].Init)(task_index);

virtual_task_continue:
	iteration_count = virtual_tasks[task_index].run_count;
	count = 0;
	
    while(CIC_V_TRUE) {
        if(tasks[task_index].state == STATE_WAIT){
            CIC_F_MUTEX_LOCK(&(virtual_tasks[task_index].mutex));
            CIC_F_COND_WAIT(&(virtual_tasks[task_index].cond), &(virtual_tasks[task_index].mutex));
            CIC_F_MUTEX_UNLOCK(&(virtual_tasks[task_index].mutex));
        }
        
		if(exit_signal)    break;
		
        // Call TASK_GO function of a task
   		(*virtual_tasks[task_index].Go)();
		
        if(exit_signal)    break;
        
        count++;
        if(virtual_tasks[task_index].driven_type = TIME_DRIVEN){
			if(iteration_count == count)	break;
		}
    }
    
    if(virtual_tasks[task_index].driven_type = TIME_DRIVEN){
		CIC_F_MUTEX_LOCK(&time_mutex);
		time_task_count++;
		CIC_F_COND_WAIT(&time_cond, &time_mutex);
		
#if defined(RESUME) && (RESUME==1)
		if(resume == true){
			CIC_F_MUTEX_UNLOCK(&time_mutex);
			goto virtual_task_continue;
		}
#endif
		CIC_F_MUTEX_UNLOCK(&time_mutex);
	}
             
	(*virtual_tasks[task_index].Wrapup)();
	tasks[task_index].state = STATE_STOP;
       
    return CIC_V_NULL;
}

CIC_UT_THREAD_FUNC_RET_TYPE TaskRoutine(CIC_UT_THREAD_FUNC_ARG_TYPE pdata)
{
	CIC_T_INT task_index = *((CIC_T_INT*)&pdata);

	CIC_T_INT iteration_count, count;
	
	if(tasks[task_index].period <= 0)	return CIC_V_NULL;
	
##SET_PROC

	if(tasks[task_index].task_type == COMPUTATIONAL){
		CIC_F_BARRIER_WAIT(&all_thread_barrier);
	}

	if(*tasks[task_index].PreInit != CIC_V_NULL) TASK_PREINIT;
	TASK_INIT;

	if(tasks[task_index].task_type == CONTROL){
		CIC_F_BARRIER_WAIT(&control_task_barrier);	// When TASK_INIT functions of control tasks are called,
		while(!all_thread_barrier_initialized){		// wait until all_thread_barrier is initialized
			CIC_F_SCHED_YIELD();
		}	
		CIC_F_BARRIER_WAIT(&all_thread_barrier);	// and wait until all threads of computational tasks are invoked.
	}
	
task_continue:   
	iteration_count = tasks[task_index].run_count;
	count = 0;

	while(CIC_V_TRUE){
		if(tasks[task_index].state == STATE_WAIT){
            CIC_F_MUTEX_LOCK(&(tasks[task_index].mutex));
            CIC_F_COND_WAIT(&(tasks[task_index].cond), &(tasks[task_index].mutex));
            CIC_F_MUTEX_UNLOCK(&(tasks[task_index].mutex));
        }
        if(global_sync){
            CIC_F_MUTEX_LOCK(&(global_mutex));
            CIC_F_COND_WAIT(&(global_cond), &(global_mutex));
            CIC_F_MUTEX_UNLOCK(&(global_mutex));
        }
        
        if(tasks[task_index].has_mtm == CIC_V_TRUE){
            CIC_T_INT i=0;
            for(i=0; i<CIC_UV_NUM_MTMS; i++)
                if(task_index == mtms[i].task_id)  break;
            mtms[i].Transition();
        }
	
		if(*tasks[task_index].PreGo != CIC_V_NULL) TASK_PREGO;
		TASK_GO;
		if(*tasks[task_index].PostGo != CIC_V_NULL) TASK_POSTGO;

        if(exit_signal || tasks[task_index].state == STATE_STOP)    break;
        
        count++;
        if(tasks[task_index].driven_type == TIME_DRIVEN){
        	if(iteration_count == count)	break;
        }
	}
	
	if(tasks[task_index].driven_type == TIME_DRIVEN){
		CIC_F_MUTEX_LOCK(&time_mutex);
		time_task_count++;
		CIC_F_COND_WAIT(&time_cond, &time_mutex);
		
#if defined(RESUME) && (RESUME==1)
		if(resume == true){
			CIC_F_MUTEX_UNLOCK(&time_mutex);
			goto task_continue;
		}
#endif
	
		CIC_F_MUTEX_UNLOCK(&time_mutex);
	}
		 
	TASK_WRAPUP;
	if(*tasks[task_index].PostWrapup != CIC_V_NULL) TASK_POSTWRAPUP;
	tasks[task_index].state = STATE_STOP;
}
##TASK_ROUTINE_END

##EXECUTE_TASKS_START
CIC_STATIC CIC_T_VOID ExecuteTasks(CIC_T_VOID)
{
	CIC_T_INT i=0;

    CIC_F_PRINT_STRING("\n------ Task thread create information ------\n");
    
    // Control barrier initialize
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
   		if(tasks[i].task_type == CONTROL){
    		control_thread_count++;
    		all_thread_count++;
    	}
    }
    CIC_F_BARRIER_INIT(&control_task_barrier, control_thread_count+1);	// +1 is for itself
    
    
    // Create threads for control tasks 
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(tasks[i].task_type == CONTROL){
	        CIC_F_PRINTF("%s task thread (Control) is created!\n", tasks[i].name);
			CIC_F_THREAD_CREATE(&(tasks[i].thread), TaskRoutine, (CIC_T_VOID *)tasks[i].task_id);
		    if(tasks[i].driven_type == TIME_DRIVEN)	num_time_task++;
		}
    }
     
    // Wait until TASK_INIT functions of all control tasks are called
    CIC_F_BARRIER_WAIT(&control_task_barrier);
      
    // All thread barrier initialize
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(tasks[i].task_type != CONTROL){
	        CIC_T_BOOL create_thread = CIC_V_FALSE;

	        if(tasks[i].parent_task_id == i)    create_thread = CIC_V_TRUE;
            else                                create_thread = CIC_V_FALSE;

	        if(create_thread == CIC_V_TRUE && tasks[i].state == STATE_RUN)	all_thread_count++;
	     }
	}
	all_thread_count+= CIC_UV_NUM_VIRTUAL_TASKS;
	
	CIC_F_BARRIER_INIT(&all_thread_barrier, all_thread_count);
	all_thread_barrier_initialized = CIC_V_TRUE;

	// Create threads for computational tasks
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(tasks[i].task_type != CONTROL){
	        CIC_T_BOOL create_thread = CIC_V_FALSE;

	        if(tasks[i].parent_task_id == i)    create_thread = CIC_V_TRUE;
            else                                create_thread = CIC_V_FALSE;

	        if(create_thread == CIC_V_TRUE && tasks[i].state == STATE_RUN){
	            CIC_F_PRINTF("%s task thread is created!\n", tasks[i].name);
	            CIC_F_THREAD_CREATE(&(tasks[i].thread), TaskRoutine, (void *)tasks[i].task_id);
	            all_thread_count++;
		        if(tasks[i].driven_type == TIME_DRIVEN)	num_time_task++;
			}
	    }
    }
    for(i=0; i<CIC_UV_NUM_VIRTUAL_TASKS; i++){
        CIC_T_BOOL create_thread = CIC_V_FALSE;

        if(virtual_tasks[i].state == STATE_RUN){
            CIC_F_PRINTF("%s virtual_task thread is created!\n", virtual_tasks[i].name);
            CIC_F_THREAD_CREATE(&(virtual_tasks[i].thread), VirtualTaskRoutine, (void *)virtual_tasks[i].task_id);
            all_thread_count++;
	        if(virtual_tasks[i].driven_type == TIME_DRIVEN)	num_time_task++;
		}
    }
    CIC_F_PRINT_STRING("--------------------------------------------\n");
    
    
    // Tasks are Running
go_continue:
	while(CIC_V_TRUE){
		fflush(stdout);
		if(time_task_count == num_time_task){
			WaitDataTasksEnd();
#if defined(RESUME) && (RESUME==1)
			fflush(stdout);
			CIC_F_SLEEP(1); 
			resume = WaitFromGUIResume();
			if(resume == CIC_V_TRUE){
				CIC_F_COND_BROADCAST(&time_cond);
				time_task_count = 0;
				channel_empty = CIC_V_FALSE;
				goto go_continue;
			}
			else{
				CIC_F_COND_BROADCAST(&time_cond);
				break;
			}
#else
			CIC_F_COND_BROADCAST(&time_cond);
			break;
#endif
		}
	}

    for(i=0; i<CIC_UV_NUM_TASKS; i++)
        CIC_F_THREAD_CANCEL(tasks[i].thread);
        
    for(i=0; i<CIC_UV_NUM_VIRTUAL_TASKS; i++)
        CIC_F_THREAD_CANCEL(virtual_tasks[i].thread);
    
	return;
}
##EXECUTE_TASKS_END

##CONTROL_RUN_TASK_START
    CIC_T_INT i=0;
    CIC_T_INT target_task_id = GetTaskId(t_name);
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(target_task_id == tasks[i].task_id){
            int task_id = tasks[i].task_id;
	        InitTaskChannel(task_id);
	        
            CIC_F_THREAD_CREATE(&(tasks[task_id].thread), TaskRoutine, (void *)task_id);
	            
	        tasks[task_id].state = STATE_RUN;
	        CIC_F_PRINTF("Run task %s (task_id: %d)\n", tasks[task_id].name, task_id);
	        break;
        }
    }  
##CONTROL_RUN_TASK_END

##CONTROL_STOP_TASK_START
    CIC_T_INT i=0;
    if(CIC_F_STRING_COMPARE(caller_task_name, t_name) == 0){
    	CIC_T_INT task_id = GetTaskId(caller_task_name);
    	CIC_T_INT parent_task_id = tasks[task_id].parent_task_id;
        CIC_F_THREAD_CANCEL(tasks[parent_task_id].thread);
        WrapupTaskChannel(parent_task_id);
        tasks[parent_task_id].state = STATE_STOP;
        PRINT("Stop a task (own)");
    }
    else{
      int target_task_id = GetTaskId(t_name);
      for(i=0; i<CIC_UV_NUM_TASKS; i++){
          if(target_task_id == tasks[i].task_id){
               CIC_T_INT task_id = tasks[i].task_id;
	           CIC_F_THREAD_CANCEL(tasks[task_id].thread);
	           WrapupTaskChannel(task_id);
	           tasks[task_id].state = STATE_STOP;
	           CIC_F_PRINTF("Stop task %s (task_id: %d)\n", tasks[task_id].name, task_id);
	           break;
          }
      } 
    }

    return;
##CONTROL_STOP_TASK_END

##CONTROL_RESUME_TASK_START
    CIC_T_INT i=0;
    CIC_T_INT target_task_id = GetTaskId(t_name);
    
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(target_task_id == tasks[i].task_id){
            CIC_T_INT task_id = tasks[i].task_id;
            if(tasks[task_id].state != STATE_STOP)	tasks[task_id].state = STATE_RUN;
            CIC_F_COND_BROADCAST(&(tasks[task_id].cond));
            CIC_F_PRINTF("Resume task %s(task_id: %d)\n", tasks[task_id].name, task_id);
            break;
        }
    } 
    return;
##CONTROL_RESUME_TASK_END

##CONTROL_SUSPEND_TASK_START
    CIC_T_INT i=0;
    
    if(CIC_F_STRING_COMPARE(caller_task_name, t_name) == 0){
        CIC_T_INT task_id = GetTaskId(caller_task_name);
        CIC_T_INT parent_task_id = tasks[task_id].parent_task_id;
        if(tasks[parent_task_id].state != STATE_STOP)	tasks[parent_task_id].state = STATE_WAIT;
        CIC_F_PRINT("Suspend a task (own)");
    }
    else{
      CIC_T_INT target_task_id = GetTaskId(t_name);
      for(i=0; i<CIC_UV_NUM_TASKS; i++){
          if(target_task_id == tasks[i].task_id){
              CIC_T_INT task_id = tasks[i].task_id;
              if(tasks[task_id].state != STATE_STOP)	 tasks[task_id].state = STATE_WAIT;
              CIC_F_PRINTF("Suspend task %s(task_id: %d)\n", tasks[task_id].name, task_id);
              break;
          }
      }  

    }
    return;
##CONTROL_SUSPEND_TASK_END
