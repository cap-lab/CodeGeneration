#define _GNU_SOURCE

//////////////////////////////////// CIC_COMMON_HEADERS /////////////////////////////////////
#include "target_system_model.h"
#include "target_task_model.h"

##EXTERNAL_GLOBAL_HEADERS

#include "cic_error.h"
#include "cic_tasks.h"
#include "cic_channels.h"
#include "cic_portmap.h"
#include "cic_control.h"
#include "cic_conmap.h"
/////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////// CIC_LIBRARY_HEADERS ////////////////////////////////////
##LIB_INCLUDES
/////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////// CIC_CONTROL_HEADERS ////////////////////////////////////
##CONN_INCLUDES
/////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////// DEFINITIONS /////////////////////////////////////////
#define CIC_UV_NUM_LIB_WRAPPERS		(CIC_T_INT)(CIC_SIZEOF(lib_wrappers)/CIC_SIZEOF(lib_wrappers[0]))
#define CIC_UV_NUM_LIB_CHANNELS		(CIC_T_INT)(CIC_SIZEOF(lib_channels)/CIC_SIZEOF(lib_channels[0]))
#define CIC_UV_NUM_TASKS	 		(CIC_T_INT)(CIC_SIZEOF(tasks)/CIC_SIZEOF(tasks[0]))
#define CIC_UV_NUM_CHANNELS	 		(CIC_T_INT)(CIC_SIZEOF(channels)/CIC_SIZEOF(channels[0]))
#define CIC_UV_NUM_PORTMAPS	 		(CIC_T_INT)(CIC_SIZEOF(addressmap)/CIC_SIZEOF(addressmap[0]))
#define CIC_UV_NUM_MTMS	 			(CIC_T_INT)(CIC_SIZEOF(mtms)/CIC_SIZEOF(mtms[0]))
#define CIC_UV_NUM_VIRTUAL_TASKS	(CIC_T_INT)(CIC_SIZEOF(virtual_tasks)/CIC_SIZEOF(virtual_tasks[0]))
#define CIC_ARRAYLEN(ARR)	 		(CIC_T_INT)(CIC_SIZEOF(ARR)/CIC_SIZEOF(ARR[0]))
/////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////// DATA STRUCTURES //////////////////////////////////////
##EXTERN_TASK_FUNCTION_DECLARATION

#define ENTRY(a, b, c, task, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {a, b, c, CIC_V_NULL, task##_Init, CIC_V_NULL, task##_Go, CIC_V_NULL, task##_Wrapup, CIC_V_NULL, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, 0}
CIC_UT_TASK tasks[] = {
##TASK_ENTRIES
};

CIC_UT_TASK virtual_tasks[] = {
##VIRTUAL_TASK_ENTRIES
};
#undef ENTRY

##EXTERN_MTM_FUNCTION_DECLARATION

#define ENTRY(a, b, task, c, d) {a, b, task##_Initialize, task##_GetCurrentModeName, task##_SetVariableInt, task##_GetVariableInt, task##_SetVariableString, task##_GetVariableString, task##_Transition, task##_UpdateCurrentMode, task##_GetTaskIterCount, task##_GetTaskRepeatCount, c, d, 0}
CIC_UT_MTM mtms[] = {
##MTM_ENTRIES
};
#undef ENTRY

CIC_UT_CHANNEL channels[] = {
##CHANNEL_ENTRIES
};

CIC_UT_PORTMAP addressmap[] = {
##PORT_ENTRIES
};

##CONNMAP_ENTRIES

##CONTROL_GROUP_COUNT
##CONTROL_CHANNEL_COUNT

##PARAM_LIST_ENTRIES

##CONTROL_CHANNEL_LIST_ENTRIES
/////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////// GLOBAL VARIABLES /////////////////////////////////////
##TASK_VARIABLE_DECLARATION
/////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////// DEBUG CODE START //////////////////////////////////////
##DEBUG_CODE_IMPLEMENTATION
////////////////////////////////////// DEBUG CODE END ///////////////////////////////////////


//////////////////////////////// TARGET DEPENDENT CODE START ////////////////////////////////
##TARGET_DEPENDENT_IMPLEMENTATION
///////////////////////////////// TARGET DEPENDENT CODE END /////////////////////////////////


///////////////////////////////// COMMUNICATION CODE START //////////////////////////////////
##COMM_CODE

##COMM_RECEIVER_ROUTINE

##COMM_SENDER_ROUTINE
///////////////////////////////// COMMUNICATION CODE END ////////////////////////////////////


/////////////////////////////// PRIMITIVE FUNCTIONS (TASKS) /////////////////////////////////
CIC_STATIC CIC_T_CHAR *GetTaskIndexForId(CIC_T_INT task_id)
{
    CIC_T_INT i;

    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(tasks[i].task_id == task_id){
        	return i;
        }
    }
    CIC_F_ERROR("proc", "GetTaskIndexForId() fail!", CIC_V_ERROR_EXIT);
    return CIC_V_NULL;
}

CIC_STATIC CIC_T_CHAR *GetTaskNameForId(CIC_T_INT task_id)
{
    CIC_T_INT i;
    CIC_T_CHAR task_id_name[10];
    CIC_F_INTEGER_TO_STRING(task_id_name, task_id);

    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(tasks[i].task_id == task_id){
        	return tasks[i].name;
        }
    }
    CIC_F_ERROR(task_id_name, "GetTaskNameForId() fail!", CIC_V_ERROR_EXIT);
    return CIC_V_NULL;
}

CIC_STATIC CIC_T_INT GetTaskIndexForName(CIC_T_CHAR* task_name)
{
    CIC_T_INT i;
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(CIC_F_STRING_COMPARE(task_name, tasks[i].name) == 0){
        	return i;
        }
    }
    CIC_F_ERROR(task_name, "GetTaskIndexForName() fail!", CIC_V_ERROR_EXIT);
    return CIC_V_ERROR;
}

CIC_STATIC CIC_T_INT GetTaskIdForName(CIC_T_CHAR* task_name)
{
    CIC_T_INT i;
    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(CIC_F_STRING_COMPARE(task_name, tasks[i].name) == 0){
        	return tasks[i].task_id;
        }
    }
    CIC_F_ERROR(task_name, "GetTaskIdForName() fail!", CIC_V_ERROR_EXIT);
    return CIC_V_ERROR;
}

CIC_STATIC CIC_T_INT GetTaskIdForChannel(CIC_T_INT channel_id, CIC_T_CHAR op)
{
	CIC_T_INT i=0;
	CIC_T_CHAR channel_id_name[13];

	for(i=0; i<CIC_UV_NUM_PORTMAPS; i++){
		if(addressmap[i].channel_id == channel_id && addressmap[i].op == op){
			return addressmap[i].task_id;
		}
	}

    CIC_F_INTEGER_TO_STRING(channel_id_name, channel_id);
	CIC_F_ERROR(channel_id_name, "GetTaskIdForChannel() fail!", CIC_V_ERROR_EXIT);
	return CIC_V_ERROR;
}

CIC_STATIC CIC_T_VOID WaitDataTasksEnd(){
	// if (all data-driven tasks are WaitBlock or ReadBlock state) && (remaining data size in all channels are less than sample size or 0)
	CIC_T_INT i=0;
	CIC_T_BOOL task_flag = CIC_V_FALSE, data_flag = CIC_V_FALSE;
	
	while(1){
		data_flag = CIC_V_FALSE;
		for(i=0; i<CIC_UV_NUM_CHANNELS; i++){
			if(channels[i].cur_size >= channels[i].sample_size && channels[i].init_data == 0){
				data_flag = CIC_V_TRUE;
				break;
			}
		}
		if(!data_flag){
			channel_empty = CIC_V_TRUE;
			break;
		}
	}

	while(1){
		task_flag = CIC_V_FALSE;
		for(i=0; i<CIC_UV_NUM_TASKS; i++){
			if(tasks[i].driven_type == DATA_DRIVEN && tasks[i].is_child_task == CIC_V_FALSE){
				if(tasks[i].run_state == RUNNING){
					task_flag = CIC_V_TRUE;
					break;
				}
			}
		}
		if(!task_flag)	break;
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////// PRIMITIVE FUNCTIONS (CHANNELS) ///////////////////////////////
// Transform task_id & port_id to channel_id
CIC_T_INT InitPort(CIC_T_INT task_id, CIC_T_INT port_id)
{
    CIC_T_UINT i;
    CIC_T_INT channel_id;

    CIC_T_CHAR task_port_name[255], port_id_name[10];
    CIC_F_INTEGER_TO_STRING(port_id_name, port_id);
    CIC_F_STRING_COPY(task_port_name, tasks[task_id].name);
    CIC_F_STRING_CONCATENATE(task_port_name, ", ");
    CIC_F_STRING_CONCATENATE(task_port_name, port_id_name);

    for(i=0; i<CIC_UV_NUM_PORTMAPS; i++){
        if(addressmap[i].task_id == task_id && addressmap[i].port_id == port_id){
            CIC_T_UINT j;
            channel_id = addressmap[i].channel_id;
            for(j=0; j<CIC_UV_NUM_CHANNELS; j++){
                if(channels[j].channel_id == channel_id)	return j;
            }
        }
    }
	CIC_F_ERROR(task_port_name, "InitPort() fail!", CIC_V_ERROR_EXIT);
    return CIC_V_ERROR;
}

// Transform task_id & port_name to channel_id
CIC_T_INT InitTaskPort(CIC_T_INT task_id, CIC_CONST CIC_T_CHAR* port_name)
{
    CIC_T_UINT i;
    CIC_T_INT channel_id;

    CIC_T_CHAR task_port_name[255];
    CIC_F_STRING_COPY(task_port_name, tasks[task_id].name);
    CIC_F_STRING_CONCATENATE(task_port_name, ", ");
    CIC_F_STRING_CONCATENATE(task_port_name, port_name);

    for(i=0; i<CIC_UV_NUM_PORTMAPS; i++){
        if(addressmap[i].task_id == task_id && CIC_F_STRING_COMPARE(addressmap[i].port_name, port_name)==0){
            CIC_T_UINT j;
            channel_id = addressmap[i].channel_id;
            for(j=0; j<CIC_UV_NUM_CHANNELS; j++){
                if(channels[j].channel_id == channel_id)	 return j;
            }
            CIC_F_ERROR(task_port_name, "InitTaskPort() fail! (Task port is not connected)", CIC_V_ERROR_EXIT);
            return CIC_V_ERROR;
        }
    }
	CIC_F_ERROR(task_port_name, "InitTaskPort() fail! (Task port is not connected)", CIC_V_ERROR_EXIT);
    return CIC_V_ERROR;
}

// Transform ch_id to the index in channels[]
CIC_T_INT GetChannelIndex(CIC_T_INT channel_id)
{
	CIC_T_UINT i;
	CIC_T_CHAR channel_id_name[10];
    CIC_F_INTEGER_TO_STRING(channel_id_name, channel_id);

	for(i=0; i<CIC_UV_NUM_CHANNELS; i++){
		if(channels[i].channel_id == channel_id)	return i;
	}
	CIC_F_ERROR(channel_id_name, "GetChannelIndex() fail! (No port is available or connected)", CIC_V_ERROR_EXIT);
	return CIC_V_ERROR;
}
/////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////// PRIMITIVE FUNCTIONS (ETC) //////////////////////////////////
##GET_CURRENT_TIME_BASE

##CHANGE_TIME_UNIT
/////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////// CHANNEL INIT/WRAPUP START /////////////////////////////////
##INIT_WRAPUP_TASK_CHANNELS

##INIT_WRAPUP_LIBRARY_CHANNELS

##INIT_WRAPUP_CHANNELS
////////////////////////////////// CHANNEL INIT/WRAPUP END //////////////////////////////////


////////////////////////////////// CHANNEL READ/WRITE START /////////////////////////////////
##READ_WRITE_PORT

##READ_WRITE_AC_PORT

##READ_WRITE_BUF_PORT

##READ_WRITE_LIB_PORT
/////////////////////////////////// CHANNEL READ/WRITE END //////////////////////////////////


////////////////////////////// LIBRARY TASK INIT/WRAPUP START ///////////////////////////////
##EXTERN_LIBRARY_INIT_WRAPUP_FUNCTION_DECLARATION

##LIB_INIT_FUNCTION

##LIB_WRAPUP_FUNCTION
/////////////////////////////// LIBRARY TASK INIT/WRAPUP END ////////////////////////////////

 
////////////////////////// STATIC SCHEDULE CODE START (IF NEEDED) ///////////////////////////
##SCHEDULE_CODE
 //////////////////////////////// STATIC SCHEDULE CODE END //////////////////////////////////


//////////////////////////////////// TASK ROUTINE START /////////////////////////////////////
##TASK_ROUTINE

##EXECUTE_TASKS
///////////////////////////////////// TASK ROUTINE END //////////////////////////////////////


///////////////////////////////////// MTM API START /////////////////////////////////////
##MTM_API
////////////////////////////////////// MTM API END //////////////////////////////////////


///////////////////////////////////// CONTROL API START /////////////////////////////////////
##CONTROL_API
////////////////////////////////////// CONTROL API END //////////////////////////////////////


////////////////////////////////// BASIC CONTROL API START //////////////////////////////////
CIC_T_VOID EndTask(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name)
{
##CONTROL_END_TASK
}

CIC_T_VOID ProgramKill()
{
    CIC_F_PRINT_STRING("----PROGRAM KILL---\n");
	CIC_F_EXIT(0);
}

CIC_T_VOID ProgramStop(CIC_T_CHAR* caller_task_name)                                                 
{             
    exit_signal = CIC_V_TRUE;
    CIC_F_PRINT_STRING("----PROGRAM STOP---\n");
    
    return;                          
}
//////////////////////////////////// BASIC CONTROL API END //////////////////////////////////
 

CIC_T_VOID InitSystemVariables(){
##INIT_SYSTEM_VARIABLES
}

CIC_T_VOID WrapupSysTemBariables(){
##WRAPUP_SYSTEM_VARIABLES
}

##MAIN_FUNCTION
{

##TARGET_DEPENDENT_INIT_CALL

	InitSystemVariables();

	InitChannels();

	##LIB_INIT
	
	##OUT_CONN_INIT

	ExecuteTasks();
	
	##OUT_CONN_WRAPUP

	##LIB_WRAPUP

	WrapupChannels();
	
	WrapupSysTemBariables();

##TARGET_DEPENDENT_WRAPUP_CALL
}
