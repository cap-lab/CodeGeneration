##DEBUG_CODE_IMPLEMENTATION_START
// For debug
#if defined(RESUME) && (RESUME==1) 
CIC_STATIC CIC_T_BOOL resume = CIC_V_FALSE;
#endif

#if defined(RESUME) && (RESUME==1)
CIC_T_VOID AdjustTaskExecutionCount(CIC_T_UCHAR type, CIC_T_INT value, char* unit){
	CIC_T_INT i=0;

	if(type == 'p' || type == 'h'){
		for(i=0; i<CIC_UV_NUM_TASKS; i++){
			if(tasks[i].driven_type == TIME_DRIVEN){
				CIC_T_ULONG metric_origin = 1, metric_new = 1;
				CIC_T_INT metric_final = 0;
				
				if(tasks[i].p_metric == H)			metric_origin = (CIC_T_ULONG)3600 * (CIC_T_ULONG)1000 * (CIC_T_ULONG)1000;
				else if(tasks[i].p_metric == M)		metric_origin = 60 * 1000 * 1000;
				else if(tasks[i].p_metric == S)		metric_origin = 1000 * 1000;
				else if(tasks[i].p_metric == MS)	metric_origin = 1000;
				else if(tasks[i].p_metric == US)	metric_origin = 1;
				else								metric_origin = 1;
				
				if(CIC_F_STRING_COMPARE(unit, "h") == 0)			metric_new = (CIC_T_ULONG)3600 * (CIC_T_ULONG)1000 * (CIC_T_ULONG)1000;
				else if(CIC_F_STRING_COMPARE(unit, "m") == 0)		metric_new = 60 * 1000 * 1000;
				else if(CIC_F_STRING_COMPARE(unit, "s") == 0)		metric_new = 1000 * 1000;
				else if(CIC_F_STRING_COMPARE(unit, "ms") == 0)		metric_new = 1 * 1000;
				else if(CIC_F_STRING_COMPARE(unit, "us") == 0)		metric_new = 1;
				else												metric_new = 1;
				
				metric_final = (int)(metric_new/metric_origin);
				tasks[i].run_count = (int)((int)((value * metric_final)/ tasks[i].period)/tasks[i].run_rate);
			}
		}
	}
	else if(type == 'd'){
		for(i=0; i<CIC_UV_NUM_TASKS; i++){
			if(tasks[i].has_subgraph == CIC_V_TRUE){
				tasks[i].run_count = value;
			}
		}
	}
}

CIC_T_BOOL WaitFromGUIResume(){
    CIC_T_UCHAR input;
    CIC_T_INT value = 0;
    CIC_T_UCHAR unit[255];
    CIC_T_UCHAR type;
 
    CIC_F_PRINT_STRING("___resume___\n");
    fflush(stdout);
    
wait_resume:
  	fflush(stdin);  
    scanf("%c\t%c\t%d\t%s", &input, &type, &value, unit);
    if(input == 'c'){
    	AdjustTaskExecutionCount(type, value, unit);
        return CIC_V_TRUE;
    }
    else if(input == 'q')   return CIC_V_FALSE;
    else                    goto wait_resume;
}
#endif

#if defined(BREAK_DEBUG) && (BREAK_DEBUG==1)
CIC_T_VOID UpdateBreak(){
    CIC_T_INT i, index, num_of_break = 0;
    CIC_T_INT src_id = -1, dst_id = -1;
    CIC_T_UCHAR src[255], dst[255];
    CIC_T_UCHAR src_port[255], dst_port[255];
    CIC_T_INT break_ch_id = -1;

    for(i=0; i<CIC_UV_NUM_CHANNELS; i++){
        channels[i].is_break = false;
    }

    FILE *fd = fopen("break.info", "r");
    if(fd == NULL)    return;

    fscanf(fd, "num_of_break: %d\n", &num_of_break);
    for(i=0; i<num_of_break; i++){
        src_id = -1, dst_id = -1;
        break_ch_id = -1;

        fscanf(fd, "%d: (src)%s (srcPort)%s (dst)%s (dstPort)%s\n", &index, src, src_port, dst, dst_port);

        for(i=0; i<CIC_UV_NUM_TASKS; i++){
            if(CIC_F_STRING_COMPARE(src, tasks[i].name) == 0)    src_id = tasks[i].task_id;
            if(CIC_F_STRING_COMPARE(dst, tasks[i].name) == 0)    dst_id = tasks[i].task_id;
            if(src_id != -1 && dst_id != -1)    break;
        }

        for(i=0; i<CIC_UV_NUM_PORTMAPS; i++){
            if(addressmap[i].task_id == dst_id && CIC_F_STRING_COMPARE(addressmap[i].port_name, dst_port) == 0){
                break_ch_id = addressmap[i].channel_id;
                CIC_T_INT break_channel_index = GetChannelIndex(break_ch_id);
                channels[break_channel_index].is_break = CIC_V_TRUE;
                break;
            }
        }
    }

    fclose(fd);
}
#endif

#if defined(WATCH_DEBUG) && (WATCH_DEBUG==1)
CIC_T_VOID UpdateWatch(){
    CIC_T_INT i, index, num_of_watch = 0;
    CIC_T_INT src_id = -1, dst_id = -1;
    CIC_T_UCHAR src[255], dst[255];
    CIC_T_UCHAR src_port[255], dst_port[255];
    CIC_T_INT watch_ch_id = -1;

    for(i=0; i<CIC_UV_NUM_CHANNELS; i++){
        channels[i].is_watch = false;
    }

    FILE *fd = fopen("watch.info", "r");
    if(fd == CIC_V_NULL)    return;

    fscanf(fd, "num_of_watch: %d\n", &num_of_watch);
    for(i=0; i<num_of_watch; i++){
        src_id = -1, dst_id = -1;
        watch_ch_id = -1;

        fscanf(fd, "%d: (src)%s (srcPort)%s (dst)%s (dstPort)%s\n", &index, src, src_port, dst, dst_port);

        for(i=0; i<CIC_UV_NUM_TASKS; i++){
            if(CIC_F_STRING_COMPARE(src, tasks[i].name) == 0)    src_id = tasks[i].task_id;
            if(CIC_F_STRING_COMPARE(dst, tasks[i].name) == 0)    dst_id = tasks[i].task_id;
            if(src_id != -1 && dst_id != -1)    break;
        }

        for(i=0; i<CIC_UV_NUM_PORTMAPS; i++){
            if(addressmap[i].task_id == dst_id && CIC_F_STRING_COMPARE(addressmap[i].port_name, dst_port) == 0){
                watch_ch_id = addressmap[i].channel_id;
                CIC_T_INT watch_channel_index = GetChannelIndex(watch_ch_id);
                channels[watch_channel_index].is_watch = CIC_V_TRUE;
                break;
            }
        }
    }

    fclose(fd);
}
#endif

#if defined(BREAK_DEBUG) && (BREAK_DEBUG==1)
CIC_T_VOID WaitFromGUIBreak(){
    CIC_T_UCHAR input;
    CIC_F_PRINT_STRING("___break___\n");
    CIC_F_MUTEX_LOCK(&global_mutex);
    global_sync = CIC_V_TRUE;
    CIC_F_MUTEX_UNLOCK(&global_mutex);
    fflush(stdout);
wait_break:
    input = getchar();
    
    CIC_F_MUTEX_LOCK(&global_mutex);
    global_sync = CIC_V_FALSE;
    CIC_F_COND_BROADCAST(&(global_cond));
    CIC_F_MUTEX_UNLOCK(&global_mutex);

    if(input == 'c')        return;
    else if(input == 'q')   CIC_F_EXIT(CIC_V_ERROR_EXIT);
    else                    goto wait_break;
}
#endif

#if (defined(WATCH_DEBUG) && (WATCH_DEBUG==1)) || (defined(BREAK_DEBUG) && (BREAK_DEBUG==1))
CIC_T_VOID DumpMQData(FILE* fd, CIC_T_INT channel_index){
	if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_INT") == 0){
        CIC_T_UCHAR* point = channels[channel_index].buf;
        while(1){
        	fprintf(fd, "%d ", *point); 
        	point += CIC_SIZEOF(int);
        	if(point >= channels[channel_index].buf + channels[channel_index].cur_size)	break;
        }
    }
    else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_UINT") == 0){
    	CIC_T_UCHAR* point = channels[channel_index].buf;
        while(1){
        	fprintf(fd, "%u ", *point); 
        	point += CIC_SIZEOF(CIC_T_UINT);
        	if(point >= channels[channel_index].buf + channels[channel_index].cur_size)	break;
        }
    }
    else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_LONG") == 0){
    	CIC_T_UCHAR* point = channels[channel_index].buf;
        while(1){
        	fprintf(fd, "%ld ", *point); 
        	point += sizeof(CIC_T_LONG);
        	if(point >= channels[channel_index].buf + channels[channel_index].cur_size)	break;
        }
    }
    else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "unsigned CIC_T_LONG") == 0){
    	CIC_T_UCHAR* point = channels[channel_index].buf;
        while(1){
        	fprintf(fd, "%lu ", *point); 
        	point += sizeof(unsigned CIC_T_LONG);
        	if(point >= channels[channel_index].buf + channels[channel_index].cur_size)	break;
        }
    }
    else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_SHORT") == 0){
   		CIC_T_UCHAR* point = channels[channel_index].buf;
        while(1){
        	fprintf(fd, "%d ", *point); 
        	point += sizeof(CIC_T_SHORT);
        	if(point >= channels[channel_index].buf + channels[channel_index].cur_size)	break;
        }
    }
    else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "unsigned CIC_T_SHORT") == 0){
    	CIC_T_UCHAR* point = channels[channel_index].buf;
        while(1){
        	fprintf(fd, "%u ", *point); 
        	point += sizeof(unsigned CIC_T_SHORT);
        	if(point >= channels[channel_index].buf + channels[channel_index].cur_size)	break;
        }
    }
    else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_FLOAT") == 0){
    	CIC_T_UCHAR* point = channels[channel_index].buf;
        while(1){
        	fprintf(fd, "%f ", *point); 
        	point += sizeof(CIC_T_FLOAT);
        	if(point >= channels[channel_index].buf + channels[channel_index].cur_size)	break;
        }
    }
    else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_DOUBLE") == 0){
   		CIC_T_UCHAR* point = channels[channel_index].buf;
        while(1){
        	fprintf(fd, "%lf ", *point); 
        	point += sizeof(CIC_T_DOUBLE);
        	if(point >= channels[channel_index].buf + channels[channel_index].cur_size)	break;
        }
    }
    else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "char") == 0){
    	CIC_T_UCHAR* point = channels[channel_index].buf;
        while(1){
        	fprintf(fd, "%c ", *point); 
        	point += sizeof(char);
        	if(point >= channels[channel_index].buf + channels[channel_index].cur_size)	break;
        }
    }
    else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_UCHAR") == 0){
    	CIC_T_UCHAR* point = channels[channel_index].buf;
        while(1){
        	fprintf(fd, "%c ", *point); 
        	point += sizeof(CIC_T_UCHAR);
        	if(point >= channels[channel_index].buf + channels[channel_index].cur_size)	break;
        }
    }
    else{      
    	fwrite(channels[channel_index].buf, 1, channels[channel_index].cur_size, fd);
    }
}

CIC_T_VOID DumpACData(FILE* fd, CIC_T_INT channel_index){
    CIC_UT_AC_DATA* point = channels[channel_index].head;
    CIC_T_INT index = 0;
    while(1){
    	if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_INT") == 0)				fprintf(fd, "(%d) %d ",  index, *(point->buf)); 
    	else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_UINT") == 0)		fprintf(fd, "(%d) %u ",  index, *(point->buf)); 
    	else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_LONG") == 0)		fprintf(fd, "(%d) %ld ", index, *(point->buf)); 
    	else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_ULONG") == 0)		fprintf(fd, "(%d) %lu ", index, *(point->buf)); 
    	else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_SHORT") == 0)		fprintf(fd, "(%d) %d ",  index, *(point->buf)); 
    	else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_USHORT") == 0)		fprintf(fd, "(%d) %u ",  index, *(point->buf)); 
    	else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_FLOAT") == 0)		fprintf(fd, "(%d) %f ",  index, *(point->buf)); 
    	else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_DOUBLE") == 0)		fprintf(fd, "(%d) %lf ", index, *(point->buf)); 
    	else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_CHAR") == 0)		fprintf(fd, "(%d) %c ",  index, *(point->buf)); 
    	else if(CIC_F_STRING_COMPARE(channels[channel_index].sample_type, "CIC_T_UCHAR") == 0)		fprintf(fd, "(%d) %c ",  index, *(point->buf)); 
    	else																						fprintf(fd, "Sample type is not specified!\n");
    	
    	index++;
    	point = &channels[channel_index].head[index];
    	if(index >= channels[channel_index].max_size/channels[channel_index].sample_size)	break;
    }
}
#endif

#if defined(WATCH_DEBUG) && (WATCH_DEBUG==1)
CIC_T_VOID DumpWatchChannelData(CIC_T_INT channel_id){
	CIC_T_INT i=0;
	CIC_T_UCHAR *src_task_name, *src_port_name, *dst_task_name, *dst_port_name;
	CIC_T_UCHAR file_name[255] = "watch_";
    CIC_T_INT channel_index = GetChannelIndex(channel_id);
	
    for(i=0; i<CIC_UV_NUM_PORTMAPS; i++){
    	if(addressmap[i].channel_id == channel_id){
    		if(addressmap[i].op == 'w'){
    			src_task_name = tasks[addressmap[i].task_id].name;
    			src_port_name = addressmap[i].port_name;
    		}
    		else if(addressmap[i].op == 'r'){
    			dst_task_name = tasks[addressmap[i].task_id].name;
    			dst_port_name = addressmap[i].port_name;
    		}
    	}
    }
    
    strcat(file_name, src_task_name);
    strcat(file_name, "_");
    strcat(file_name, src_port_name);
    strcat(file_name, dst_task_name);
    strcat(file_name, "_");
    strcat(file_name, dst_port_name);
    strcat(file_name, ".info");
    
	FILE *fd = fopen(file_name, "a+");
	
	if(channels[channel_index].type == CIC_UT_CHANNEL_TYPE_ARRAY_CHANNEL)	DumpACData(fd, channel_index);
    else														      		DumpMQData(fd, channel_index);
    
    fprintf(fd, "\n");
    
    fclose(fd);
}
#endif

#if defined(BREAK_DEBUG) && (BREAK_DEBUG==1)
CIC_T_VOID DumpBreakChannelData(CIC_T_INT channel_id){
	CIC_T_INT i=0;
	CIC_T_UCHAR *src_task_name, *src_port_name, *dst_task_name, *dst_port_name;
    CIC_T_INT channel_index = GetChannelIndex(channel_id);
	
    FILE *fd = fopen("break_channel.dump", "wb");
    fprintf(fd, "*. Channel info\n");
    for(i=0; i<CIC_UV_NUM_PORTMAPS; i++){
    	if(addressmap[i].channel_id == channel_id){
    		if(addressmap[i].op == 'w'){
    			src_task_name = tasks[addressmap[i].task_id].name;
    			src_port_name = addressmap[i].port_name;
    		}
    		else if(addressmap[i].op == 'r'){
    			dst_task_name = tasks[addressmap[i].task_id].name;
    			dst_port_name = addressmap[i].port_name;
    		}
    	}
    }
    fprintf(fd, "  1) channel: (srcTask)%s, (srcPort)%s, (dstTask)%s, (dstPort)%s\n", src_task_name, src_port_name, dst_task_name, dst_port_name);
    fprintf(fd, "  2) max size: %d\n", channels[channel_index].max_size);
    fprintf(fd, "  3) cur size: %d\n", channels[channel_index].cur_size);
    fprintf(fd, "  4) sample size: %d\n", channels[channel_index].sample_size);
    fprintf(fd, "  5) sample type: %s\n", channels[channel_index].sample_type);
    fprintf(fd, "  6) data: ");
  	if(channels[channel_index].type == CIC_UT_CHANNEL_TYPE_ARRAY_CHANNEL)	DumpACData(fd, channel_index);
    else																    DumpMQData(fd, channel_index);
    
    fclose(fd);
}
#endif
##DEBUG_CODE_IMPLEMENTATION_END