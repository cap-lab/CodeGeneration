#include "mtm.h"
#include "cic_error.h"

##NUMSUBTASKS

CIC_STATIC CIC_UT_MODEMAP mode_map[] = {
##MODEMAP
};

CIC_STATIC CIC_UT_INT_VAR int_var_map[] = {
##INTVARMAP
};

CIC_STATIC CIC_UT_STR_VAR string_var_map[] = {
##STRINGVARMAP
};

CIC_TYPEDEF CIC_T_STRUCT{
    CIC_T_CHAR* task_name;
    CIC_T_INT count[2];
    CIC_T_INT curr;
}CIC_UT_TASK_COUNT_INFO;

CIC_STATIC CIC_UT_TASK_COUNT_INFO task_iter_info[] = {
##TASKITERINFO
};

CIC_STATIC CIC_T_INT complete_task_count;
CIC_STATIC CIC_T_BOOL is_transition;
CIC_STATIC CIC_T_INT current_mode, next_mode;
CIC_STATIC CIC_T_INT src_continue_count;
CIC_STATIC CIC_T_INT continue_count[NUM_SUB_TASKS];

CIC_STATIC CIC_T_MUTEX mtm_mutex = CIC_V_MUTEX_INIT_INLINE;
CIC_STATIC CIC_T_COND mtm_cond = CIC_V_COND_INIT_INLINE;

MTM_INITIALIZE
{
	CIC_T_INT i = 0;
	for(i=0; i<NUM_SUB_TASKS; i++){
		continue_count[i] = 0;
	}
	
	is_transition = CIC_V_FALSE;
	CIC_F_MUTEX_INIT(&mtm_mutex);
	CIC_F_COND_INIT(&mtm_cond);
}

UPDATE_CURRENT_MODE
{
	CIC_T_INT i=0;
	CIC_T_INT task_index = 0;

	// get task_id
    for(i=0; i<CIC_ARRAYLEN(task_iter_info); i++){
        if(CIC_F_STRING_COMPARE(task_name, task_iter_info[i].task_name) == 0){
			task_index = i;
			break;
		}
	}

	CIC_F_MUTEX_LOCK(&mtm_mutex);
	
	if(continue_count[task_index] >= src_continue_count){
		complete_task_count++;
		if(is_transition && complete_task_count >= NUM_SUB_TASKS - 1){
			for(i=0; i<NUM_SUB_TASKS; i++){
				continue_count[i] = 0;
			}
			complete_task_count--;
			current_mode = next_mode;
			src_continue_count = 1;
			is_transition = CIC_V_FALSE;
			CIC_F_COND_BROADCAST(&mtm_cond);
		}
		else{
			CIC_F_COND_WAIT(&mtm_cond, &mtm_mutex);
			complete_task_count--;
		}
	}
	continue_count[task_index]++;
	CIC_F_MUTEX_UNLOCK(&mtm_mutex);
}

GET_TASK_REPEAT_COUNT
{
    return CIC_V_ERROR;
}

GET_TASK_ITER_COUNT
{
    return CIC_V_ERROR;
}

GET_CURRENT_MODE_NAME
{
	return mode_map[current_mode].name;
}

SET_VARIABLE_INT
{
    CIC_T_INT i=0;
    for(i=0; i<CIC_ARRAYLEN(int_var_map); i++){
        if(CIC_F_STRING_COMPARE(int_var_map[i].name, name) == 0){
            int_var_map[i].value = value;
        }
    }
}

SET_VARIABLE_STRING
{
    CIC_T_INT i=0;
    for(i=0; i<CIC_ARRAYLEN(string_var_map); i++){
        if(CIC_F_STRING_COMPARE(string_var_map[i].name, name) == 0){
            CIC_F_STRING_COPY(string_var_map[i].value, value);
        }
    }
}

GET_VARIABLE_INT
{
    CIC_T_INT i=0;
    for(i=0; i<CIC_ARRAYLEN(int_var_map); i++){
        if(CIC_F_STRING_COMPARE(int_var_map[i].name, name) == 0){
            return int_var_map[i].value;
        }
    }
    CIC_F_ERROR(name, "GetVariableInt() fail", CIC_V_ERROR_EXIT);
    return CIC_V_ERROR;
}

GET_VARIABLE_STRING
{
    CIC_T_INT i=0;
    for(i=0; i<CIC_ARRAYLEN(string_var_map); i++){
        if(CIC_F_STRING_COMPARE(string_var_map[i].name, name) == 0){
            return string_var_map[i].value;
        }
    }
    CIC_F_ERROR(name, "GetVariableString() fail", CIC_V_ERROR_EXIT);
    return CIC_V_NULL;
}

TRANSITION
{
	CIC_T_INT i=0;
##TRANS_VAR_INIT
	
	CIC_F_MUTEX_LOCK(&mtm_mutex);
##TRANSITION

	if(is_transition){
		if(complete_task_count >= NUM_SUB_TASKS - 1){
			for(i=0; i<NUM_SUB_TASKS; i++){
				continue_count[i] = 0;
			}
			current_mode = next_mode;
			src_continue_count = 1;
			is_transition = CIC_V_FALSE;
		}
		else{
			CIC_F_COND_WAIT(&mtm_cond, &mtm_mutex);
		}
	}
	CIC_F_COND_BROADCAST(&mtm_cond);
	CIC_F_MUTEX_UNLOCK(&mtm_mutex);
}
