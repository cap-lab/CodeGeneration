#include "mtm.h"
#include "cic_error.h"

#define MODE_QUEUE_SIZE 10
##NUMSUBTASKS

CIC_STATIC CIC_UT_MODEMAP mode_map[] = {
##MODEMAP
};

CIC_STATIC CIC_UT_INT_VAR int_var_map[] = {
##INTVARMAP
};

CIC_STATIC CIC_UT_STR_VAR string_var_map[] = {
##STRINGVARMAP
};

CIC_TYPEDEF CIC_T_STRUCT{
    CIC_T_CHAR* task_name;
    CIC_T_INT count[2];
    CIC_T_INT curr;
}CIC_UT_TASK_COUNT_INFO;

CIC_STATIC CIC_UT_TASK_COUNT_INFO task_iter_info[] = {
##TASKITERINFO
};

##SRCTASKINDEX
CIC_STATIC CIC_T_INT current_mode_queue[MODE_QUEUE_SIZE][2] = {{0, -1}, {0, -1}, {0, -1}, {0, -1}, {0, -1}, {0, -1}, {0, -1}, {0, -1}, {0, 1}, {0, 1}};
CIC_STATIC CIC_T_INT *mode_pointer[NUM_SUB_TASKS] = {0x0, };
CIC_STATIC CIC_T_INT *most_recent_mode_pointer = 0x0;
CIC_STATIC CIC_T_INT current_mode;
CIC_STATIC CIC_T_INT continue_count[NUM_SUB_TASKS] = {0, };

CIC_STATIC CIC_T_MUTEX trans_mutex = CIC_V_MUTEX_INIT_INLINE;
CIC_STATIC CIC_T_MUTEX read_mutex = CIC_V_MUTEX_INIT_INLINE;
CIC_STATIC CIC_T_COND read_cond = CIC_V_COND_INIT_INLINE;
CIC_STATIC CIC_T_MUTEX write_mutex = CIC_V_MUTEX_INIT_INLINE;
CIC_STATIC CIC_T_COND write_cond = CIC_V_COND_INIT_INLINE;
CIC_STATIC CIC_T_MUTEX is_full_mutex = CIC_V_MUTEX_INIT_INLINE;

MTM_INITIALIZE
{
	CIC_T_INT i=0;
	for(i=0; i<NUM_SUB_TASKS; i++){
		if(mode_pointer[i] == 0x0){
			if(i == src_task_index) mode_pointer[i] = current_mode_queue[MODE_QUEUE_SIZE] - 4;
			else					mode_pointer[i] = current_mode_queue[MODE_QUEUE_SIZE] - 2;
		}
	}
	if(most_recent_mode_pointer == 0x0)	most_recent_mode_pointer = current_mode_queue[0] + 2;
}

UPDATE_CURRENT_MODE
{
	CIC_T_INT i=0;
	CIC_T_INT task_index = 0;
	CIC_T_BOOL is_empty_slot = CIC_V_TRUE;

	// get task_id
    for(i=0; i<CIC_ARRAYLEN(task_iter_info); i++){
        if(CIC_F_STRING_COMPARE(task_name, task_iter_info[i].task_name) == 0){
			task_index = i;
			break;
		}
	}

	// update current mode pointer
	mode_pointer[task_index]+=2;
	if(task_index != src_task_index)	continue_count[task_index] = 0;
	if(mode_pointer[task_index] == current_mode_queue[MODE_QUEUE_SIZE])	mode_pointer[task_index] = current_mode_queue[0];

	// read blocking case
	if(mode_pointer[task_index] == most_recent_mode_pointer){
		CIC_F_MUTEX_LOCK(&read_mutex);
		CIC_F_COND_WAIT(&read_cond, &read_mutex);
		CIC_F_MUTEX_UNLOCK(&read_mutex);
	}

	// check awake condition of writer
	// if a slot in current_mode_queue is available, wakeup source task to write a current mode of next iteration
	for(i=0; i<NUM_SUB_TASKS; i++){
		CIC_T_INT *next_mode_pos = most_recent_mode_pointer + 2;
		if(next_mode_pos == current_mode_queue[MODE_QUEUE_SIZE])	next_mode_pos = current_mode_queue[0];
		if(mode_pointer[i] == next_mode_pos){
			is_empty_slot = CIC_V_FALSE;
			break;
		}
	}
	if(is_empty_slot){
		CIC_F_COND_BROADCAST(&write_cond);
	}
}

GET_TASK_REPEAT_COUNT
{
    CIC_T_INT i=0;
	CIC_T_INT task_index = 0;
	CIC_T_INT *prev_pointer = CIC_V_NULL;

	// get task_id
    for(i=0; i<CIC_ARRAYLEN(task_iter_info); i++){
        if(CIC_F_STRING_COMPARE(task_name, task_iter_info[i].task_name) == 0){
			task_index = i;
			break;
		}
	}
	
	prev_pointer = most_recent_mode_pointer - 2;
	if(prev_pointer < current_mode_queue[0]){
		prev_pointer = current_mode_queue[MODE_QUEUE_SIZE] - 2;
	}

	CIC_F_MUTEX_LOCK(&trans_mutex);
	if(task_index != src_task_index && mode_pointer[task_index][1] == -1 && continue_count[task_index] >= continue_count[src_task_index]){
		CIC_F_MUTEX_UNLOCK(&trans_mutex);
		CIC_F_MUTEX_LOCK(&read_mutex);
		CIC_F_COND_WAIT(&read_cond, &read_mutex);
		CIC_F_MUTEX_UNLOCK(&read_mutex);
	}
	else	CIC_F_MUTEX_UNLOCK(&trans_mutex);
	
	if(task_index != src_task_index)	continue_count[task_index]++;
	return mode_pointer[task_index][1];
}

GET_TASK_ITER_COUNT
{
    CIC_T_INT i=0;
	CIC_T_INT task_index = 0;
	CIC_T_INT curr_mode = 0;

	// get task_id
    for(i=0; i<CIC_ARRAYLEN(task_iter_info); i++){
        if(CIC_F_STRING_COMPARE(task_name, task_iter_info[i].task_name) == 0){
			task_index = i;
			break;
		}
	}

	// get current mode
	curr_mode = mode_pointer[task_index][0];

    return task_iter_info[task_index].count[curr_mode];
}


GET_CURRENT_MODE_NAME
{
	CIC_T_INT i=0;
	CIC_T_INT task_index = -1, mode_index = 0;
	
    for(i=0; i<CIC_ARRAYLEN(task_iter_info); i++){
        if(CIC_F_STRING_COMPARE(task_name, task_iter_info[i].task_name) == 0){
			task_index = i;
			break;
		}
	}
	
	mode_index = mode_pointer[task_index][0];
    return mode_map[mode_index].name;
}


SET_VARIABLE_INT
{
    CIC_T_INT i=0;
    for(i=0; i<CIC_ARRAYLEN(int_var_map); i++){
        if(CIC_F_STRING_COMPARE(int_var_map[i].name, name) == 0){
            int_var_map[i].value = value;
        }
    }
}

SET_VARIABLE_STRING
{
    CIC_T_INT i=0;
    for(i=0; i<CIC_ARRAYLEN(string_var_map); i++){
        if(CIC_F_STRING_COMPARE(string_var_map[i].name, name) == 0){
            CIC_F_STRING_COPY(string_var_map[i].value, value);
        }
    }
}

GET_VARIABLE_INT
{
    CIC_T_INT i=0;
    for(i=0; i<CIC_ARRAYLEN(int_var_map); i++){
        if(CIC_F_STRING_COMPARE(int_var_map[i].name, name) == 0){
            return int_var_map[i].value;
        }
    }
    CIC_F_ERROR(name, "GetVariableInt() fail", CIC_V_ERROR_EXIT);
    return CIC_V_ERROR;
}

GET_VARIABLE_STRING
{
    CIC_T_INT i=0;
    for(i=0; i<CIC_ARRAYLEN(string_var_map); i++){
        if(CIC_F_STRING_COMPARE(string_var_map[i].name, name) == 0){
            return string_var_map[i].value;
        }
    }
    CIC_F_ERROR(name, "GetVariableString() fail", CIC_V_ERROR_EXIT);
    return CIC_V_NULL;
}

TRANSITION
{
	CIC_T_INT i=0;
	CIC_T_BOOL is_full = CIC_V_FALSE, is_transition = CIC_V_FALSE;
##TRANS_VAR_INIT
	
	// check write blocking case
	for(i=0; i<NUM_SUB_TASKS; i++){
		CIC_T_INT *most_near_pos = mode_pointer[i];
		if(most_near_pos == current_mode_queue)	most_near_pos = current_mode_queue[MODE_QUEUE_SIZE] - 2;
		else									most_near_pos = mode_pointer[i] - 2;
		if(most_near_pos == most_recent_mode_pointer){
			is_full = CIC_V_TRUE;
			break;
		}
	}

	if(is_full){
		CIC_F_MUTEX_LOCK(&write_mutex);
		CIC_F_COND_WAIT(&write_cond, &write_mutex);
		CIC_F_MUTEX_UNLOCK(&write_mutex);
	}
	
	CIC_F_MUTEX_LOCK(&trans_mutex);
	
##TRANSITION

	// update current mode pointer
	if(is_transition){
		CIC_T_INT *prev_pointer = most_recent_mode_pointer - 2;
		if(prev_pointer < current_mode_queue[0]){
			prev_pointer = current_mode_queue[MODE_QUEUE_SIZE] - 2;
		}
		prev_pointer[1] = continue_count[src_task_index];
		most_recent_mode_pointer[0] = current_mode;
		most_recent_mode_pointer[1] = -1;
		continue_count[src_task_index] = 1;	

		most_recent_mode_pointer+=2;
		if(most_recent_mode_pointer == current_mode_queue[MODE_QUEUE_SIZE]){
			most_recent_mode_pointer = current_mode_queue[0];
		}
	}

	CIC_F_COND_BROADCAST(&read_cond);
	CIC_F_MUTEX_UNLOCK(&trans_mutex);
}
