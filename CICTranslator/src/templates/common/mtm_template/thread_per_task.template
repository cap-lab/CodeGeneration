#include "mtm.h"
#include "cic_error.h"

#define MODE_QUEUE_SIZE 10
##NUMSUBTASKS

CIC_STATIC CIC_UT_MODEMAP mode_map[] = {
##MODEMAP
};

CIC_STATIC CIC_UT_INT_VAR int_var_map[] = {
##INTVARMAP
};

CIC_STATIC CIC_UT_STR_VAR string_var_map[] = {
##STRINGVARMAP
};

CIC_TYPEDEF CIC_T_STRUCT{
    CIC_T_CHAR* task_name;
    CIC_T_INT count[2];
    CIC_T_INT curr;
}CIC_UT_TASK_COUNT_INFO;

CIC_STATIC CIC_UT_TASK_COUNT_INFO task_iter_info[] = {
##TASKITERINFO
};

##SRCTASKINDEX
CIC_STATIC CIC_T_INT current_mode_queue[MODE_QUEUE_SIZE][2];
CIC_STATIC CIC_T_INT *mode_pointer[NUM_SUB_TASKS];
CIC_STATIC CIC_T_INT current_mode;
CIC_STATIC CIC_T_INT src_continue_count;

CIC_STATIC CIC_T_MUTEX read_mutex = CIC_V_MUTEX_INIT_INLINE;
CIC_STATIC CIC_T_COND read_cond = CIC_V_COND_INIT_INLINE;
CIC_STATIC CIC_T_MUTEX write_mutex = CIC_V_MUTEX_INIT_INLINE;
CIC_STATIC CIC_T_COND write_cond = CIC_V_COND_INIT_INLINE;

MTM_INITIALIZE
{
	CIC_T_INT i=0;
	
	for(i=0; i<MODE_QUEUE_SIZE; i++){
		current_mode_queue[i][0] = 0;
		current_mode_queue[i][1] = -1;
	}
	
	for(i=0; i<NUM_SUB_TASKS; i++){
		if(i != src_task_index)	mode_pointer[i] = current_mode_queue[MODE_QUEUE_SIZE] - 2;
		else					mode_pointer[i] = current_mode_queue;
	}
}

UPDATE_CURRENT_MODE
{
	CIC_T_INT i=0;
	CIC_T_INT task_index = 0;
	CIC_T_BOOL is_empty_slot = CIC_V_TRUE;

	// get task_id
    for(i=0; i<CIC_ARRAYLEN(task_iter_info); i++){
        if(CIC_F_STRING_COMPARE(task_name, task_iter_info[i].task_name) == 0){
			task_index = i;
			break;
		}
	}

	// update current mode pointer
	CIC_F_MUTEX_LOCK(&write_mutex);
	mode_pointer[task_index]+=2;
	if(mode_pointer[task_index] == current_mode_queue[MODE_QUEUE_SIZE]){
		mode_pointer[task_index] = current_mode_queue;
	}

	// check awake condition of writer
	// if a slot in current_mode_queue is available, wakeup source task to write a current mode of next iteration
	CIC_T_INT *next_src_pos = mode_pointer[src_task_index] + 2;
	if(next_src_pos == current_mode_queue[MODE_QUEUE_SIZE])	next_src_pos = current_mode_queue;
	for(i=0; i<NUM_SUB_TASKS; i++){
		if(i != src_task_index && mode_pointer[i] == next_src_pos){
			is_empty_slot = CIC_V_FALSE;
			break;
		}
	}
	if(is_empty_slot){
		CIC_F_COND_BROADCAST(&write_cond);
	}
	CIC_F_MUTEX_UNLOCK(&write_mutex);
}

GET_TASK_REPEAT_COUNT
{
    CIC_T_INT i=0;
	CIC_T_INT task_index = 0;

	// get task_id
    for(i=0; i<CIC_ARRAYLEN(task_iter_info); i++){
        if(CIC_F_STRING_COMPARE(task_name, task_iter_info[i].task_name) == 0){
			task_index = i;
			break;
		}
	}

	CIC_F_MUTEX_LOCK(&read_mutex);
	if(mode_pointer[task_index][1] == -1 && src_continue_count <= run_count){
		CIC_F_COND_WAIT(&read_cond, &read_mutex);
	}
	CIC_F_MUTEX_UNLOCK(&read_mutex);
	
	return mode_pointer[task_index][1];
}

GET_TASK_ITER_COUNT
{
    CIC_T_INT i=0;
	CIC_T_INT task_index = 0;
	CIC_T_INT curr_mode = 0;

	// get task_id
    for(i=0; i<CIC_ARRAYLEN(task_iter_info); i++){
        if(CIC_F_STRING_COMPARE(task_name, task_iter_info[i].task_name) == 0){
			task_index = i;
			break;
		}
	}

	// get current mode
	curr_mode = mode_pointer[task_index][0];

    return task_iter_info[task_index].count[curr_mode];
}

GET_TASK_ITER_COUNT_FROM_MODE_NAME
{
	CIC_T_INT i=0;
	CIC_T_INT task_index = 0;
	CIC_T_INT curr_mode = 0;
 
	// get task_id
	for(i=0; i<CIC_ARRAYLEN(task_iter_info); i++){
		if(CIC_F_STRING_COMPARE(task_name, task_iter_info[i].task_name) == 0){
			task_index = i;
			break;
		}
	}

	// get current mode
	for(i = 0; i < CIC_ARRAYLEN(mode_map); i++)
	{
		if(CIC_F_STRING_COMPARE(mode_name, mode_map[i].name) == 0){
			curr_mode = mode_map[i].id;
			break;
		}
	}
	return task_iter_info[task_index].count[curr_mode];
}

GET_CURRENT_MODE_NAME
{
	CIC_T_INT i=0;
	CIC_T_INT task_index = -1, mode_index = 0;
	
    for(i=0; i<CIC_ARRAYLEN(task_iter_info); i++){
        if(CIC_F_STRING_COMPARE(task_name, task_iter_info[i].task_name) == 0){
			task_index = i;
			break;
		}
	}
	
	mode_index = mode_pointer[task_index][0];
    return mode_map[mode_index].name;
}


SET_VARIABLE_INT
{
    CIC_T_INT i=0;
    for(i=0; i<CIC_ARRAYLEN(int_var_map); i++){
        if(CIC_F_STRING_COMPARE(int_var_map[i].name, name) == 0){
            int_var_map[i].value = value;
        }
    }
}

SET_VARIABLE_STRING
{
    CIC_T_INT i=0;
    for(i=0; i<CIC_ARRAYLEN(string_var_map); i++){
        if(CIC_F_STRING_COMPARE(string_var_map[i].name, name) == 0){
            CIC_F_STRING_COPY(string_var_map[i].value, value);
        }
    }
}

GET_VARIABLE_INT
{
    CIC_T_INT i=0;
    for(i=0; i<CIC_ARRAYLEN(int_var_map); i++){
        if(CIC_F_STRING_COMPARE(int_var_map[i].name, name) == 0){
            return int_var_map[i].value;
        }
    }
    CIC_F_ERROR(name, "GetVariableInt() fail", CIC_V_ERROR_EXIT);
    return CIC_V_ERROR;
}

GET_VARIABLE_STRING
{
    CIC_T_INT i=0;
    for(i=0; i<CIC_ARRAYLEN(string_var_map); i++){
        if(CIC_F_STRING_COMPARE(string_var_map[i].name, name) == 0){
            return string_var_map[i].value;
        }
    }
    CIC_F_ERROR(name, "GetVariableString() fail", CIC_V_ERROR_EXIT);
    return CIC_V_NULL;
}

TRANSITION
{
	CIC_T_INT i=0;
	CIC_T_BOOL is_full = CIC_V_FALSE, is_transition = CIC_V_FALSE;
	CIC_T_INT next_mode = 0;
##TRANS_VAR_INIT
	
	CIC_F_MUTEX_LOCK(&write_mutex);
##TRANSITION

	// update current mode pointer
	if(is_transition){
		// check write blocking case
		CIC_T_INT *next_src_pos = mode_pointer[src_task_index] + 2;
		if(next_src_pos == current_mode_queue[MODE_QUEUE_SIZE])	next_src_pos = current_mode_queue;
		for(i=0; i<NUM_SUB_TASKS; i++){
			if(i != src_task_index && next_src_pos == mode_pointer[i]){
				is_full = CIC_V_TRUE;
				break;
			}
		}

		if(is_full){
			CIC_F_COND_WAIT(&write_cond, &write_mutex);
		}

		if(src_continue_count == 0)	src_continue_count = 1;
		mode_pointer[src_task_index][0] = current_mode;
		mode_pointer[src_task_index][1] = src_continue_count;
		mode_pointer[src_task_index] += 2;
		if(mode_pointer[src_task_index] == current_mode_queue[MODE_QUEUE_SIZE]){
			mode_pointer[src_task_index] = current_mode_queue;
		}
		mode_pointer[src_task_index][0] = next_mode;
		mode_pointer[src_task_index][1] = -1;
		src_continue_count = 1;
		current_mode = next_mode;
	}
	CIC_F_MUTEX_UNLOCK(&write_mutex);
	
	CIC_F_MUTEX_LOCK(&read_mutex);
	CIC_F_COND_BROADCAST(&read_cond);
	CIC_F_MUTEX_UNLOCK(&read_mutex);
	
	return is_transition;
}
