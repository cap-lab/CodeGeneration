##INIT_WRAPUP_CHANNELS_START
static void init_channel(void)
{
    int i;
    volatile unsigned int *init_flag = (unsigned int *)(SHARED_BASE + SHARED_SIZE - 4);

    if((unsigned int)init_flag % 4 != 0)
    {
        printf(PROC_NAME ":init_channel(): init_flag should be 4-byte aligned!\n");
        EXIT(1);
    }

    for(i=0; i<ARRAYLEN(channels); ++i)
    {
        volatile unsigned int *ptr;

        ptr = (unsigned int *)(SHARED_BASE + c_gap);
        if((unsigned int)ptr % 4 != 0)
        {
            printf(PROC_NAME ":init_channel(): ptr should be 4-byte aligned!\n");
            EXIT(1);
        }

        if(channels[i].type == CHANNEL_TYPE_NORMAL || channels[i].type == CHANNEL_TYPE_BUFFER)
        {
            if(channels[i].max_size <= 0)
            {
                printf("init_channel(): size should be positive!\n");
                EXIT(1);
            }

            c_gap += 3*sizeof(int) + SIZE_ALIGN(channels[i].max_size);

            waiting_reader_task_list[i] = (int *)(unsigned int *)(SHARED_BASE + c_gap);
            c_gap += waiting_reader_task_list_size[i]*sizeof(int);

            waiting_writer_task_list[i] = (int *)(unsigned int *)(SHARED_BASE + c_gap);
            c_gap += waiting_writer_task_list_size[i]*sizeof(int);
        }
        else if(channels[i].type == CHANNEL_TYPE_ARRAY_CHANNEL)
        {
            if(channels[i].max_size <= 0)
            {
                printf("init_channel(): size should be positive!\n");
                EXIT(1);
            }

            if(channels[i].sampleSize <= 0)
            {
                printf("init_channel(): sampleSize should be positive!\n");
                EXIT(1);
            }

            if(channels[i].max_size % channels[i].sampleSize != 0)
            {
                printf("init_channel(): size should be divided by sampleSize!\n");
                EXIT(1);
            }

            if(channels[i].max_size / channels[i].sampleSize <= channels[i].initData)
            {
                printf("init_channel(): initData is too large!\n");
                EXIT(1);
            }

            if(waiting_reader_task_list_size[i] < 1)
            {
                printf("init_channel(): waiting_reader_task_list_size is too small!\n");
                EXIT(1);
            }

            if(waiting_writer_task_list_size[i] < 1)
            {
                printf("init_channel(): waiting_writer_task_list_size is too small!\n");
                EXIT(1);
            }

            c_gap += (sizeof(int) + SIZE_ALIGN(channels[i].sampleSize)) * (channels[i].max_size / channels[i].sampleSize);

            waiting_reader_task_list[i] = (int *)(unsigned int *)(SHARED_BASE + c_gap);
            c_gap += waiting_reader_task_list_size[i]*sizeof(int);

            waiting_writer_task_list[i] = (int *)(unsigned int *)(SHARED_BASE + c_gap);
            c_gap += waiting_writer_task_list_size[i]*sizeof(int);
        }

        if(channels[i].type == CHANNEL_TYPE_NORMAL || channels[i].type == CHANNEL_TYPE_BUFFER)
        {
            ptr[0] = channels[i].initData;
            ptr[1] = 0;
            waiting_reader_task_list[i][0] = waiting_writer_task_list[i][0] = -1;
        }
        else if(channels[i].type == CHANNEL_TYPE_ARRAY_CHANNEL)
        {
            int j;
            for(j=0;j<channels[i].initData;j++)
            {
                ptr[(j*(sizeof(int)+SIZE_ALIGN(channels[i].sampleSize)))/(sizeof(int)/sizeof(char))] = 1;
            }
            for(j=channels[i].initData;j<channels[i].max_size/channels[i].sampleSize;j++)
            {
                ptr[(j*(sizeof(int)+SIZE_ALIGN(channels[i].sampleSize)))/(sizeof(int)/sizeof(char))] = 0;
            }
            for(j=0;j<waiting_reader_task_list_size[i];j++)
            {
                waiting_reader_task_list[i][j] = -1;
            }
            for(j=0;j<waiting_writer_task_list_size[i];j++)
            {
                waiting_writer_task_list[i][j] = -1;
            }

        }
        channels[i].buf = &ptr[0];
    }

}

static void wrapup_channel(void)
{
    // do nothing....
}
##INIT_WRAPUP_CHANNELS_END

##INIT_WRAPUP_TASK_CHANNELS_START
static void init_task_channel(int parent_task_id){
    // Need to fix
}

static void wrapup_task_channel(int task_id){

}
##INIT_WRAPUP_TASK_CHANNELS_END

##READ_WRITE_PORT_START
int read_port(int channel_id, unsigned char *buf, int len) //blocking
{
    volatile unsigned int *base;
    unsigned int c_head;
    unsigned int c_tail;
    unsigned int c_size;

    CHANNEL *channel;
    channel = &channels[channel_id];

    base = channel->buf;
    c_tail = base[1];

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    {
        int i;
        unsigned int c_size;
        unsigned int c_head = base[0];
        if (c_head >= c_tail) {
            c_size = c_head - c_tail;
        } else {
            c_size = c_head + channel->max_size + sizeof(int) - c_tail;
        }
        check_valid_operation(channel_id, CHANNEL_TYPE_NORMAL, 'r');
        for(i=1; i<ARRAYLEN(addressmap); i++)
        {
            if(addressmap[i].task_id != get_mytask_id() &&
                addressmap[i].channel_id == channel_id &&
                addressmap[i].op == 'w')
            {
                i = addressmap[i].task_id;
                break;
            }
        }
        printf("PROC_DEBUG(CH) " PROC_NAME ".%s read %d(from'%s') %d %d/%d start\n", get_task_name(get_mytask_id()), channel_id, get_task_name(i), len, c_size, channel->max_size);
    }
#endif

#if defined(PARAM_DEBUG) && (PARAM_DEBUG==1)
    if(len < 0)
    {
        printf("%d %d\n", channel_id, len);
        printf("read_port(): len should be larger than 0!\n");
        exit(EXIT_SUCCESS);
    }

    if(len > channel->max_size)
    {
        printf("read_port(): max_size is too small!\n");
        exit(EXIT_FAILURE);
    }
#endif

    do {
        c_head = base[0];
        if (c_head >= c_tail) {
            c_size = c_head - c_tail;
        } else {
            c_size = c_head + channel->max_size + sizeof(int) - c_tail;
        }
        if (c_size < len) {
                OSSchedUnlock();
                CIC_task_sleep(channel, 'r');
                OSSchedLock();
        }
        else
            break;
    } while (1);

    if ((c_tail + len) > channel->max_size + sizeof(int)) {
        unsigned int s1, s2;
        s1 = channel->max_size + sizeof(int) - c_tail;
        s2 = len - s1;

        memcpy(buf, (char *)(base + 2) + c_tail, s1);
        memcpy(buf + s1, (char *)(base + 2), s2);
    } else {
        memcpy(buf, (char *)(base + 2) + c_tail, len);
    }

    c_tail += len;
    if (c_tail >= channel->max_size + sizeof(int))
        c_tail -= channel->max_size + sizeof(int);

    base[1] = c_tail;

    CIC_task_notify(channel, 'r');//KJW added

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    {
        int i;
        for(i=1; i<ARRAYLEN(addressmap); i++)
        {
            if(addressmap[i].task_id != get_mytask_id() &&
                addressmap[i].channel_id == channel_id &&
                addressmap[i].op == 'w')
            {
                i = addressmap[i].task_id;
                break;
            }
        }
        printf("PROC_DEBUG(CH) " PROC_NAME ".%s read %d(from'%s') %d %d/%d end\n", get_task_name(get_mytask_id()), channel_id, get_task_name(i), len, c_size - len, channel->max_size);
    }
#endif

    return len;
}

int write_one_port(CHANNEL* channel, unsigned char *buf, int len)
{
    volatile unsigned int *base;
    unsigned int c_head;
    unsigned int c_tail;
    unsigned int c_size;

    base = channel->buf;
    c_head = base[0];

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    {
        int i;
        unsigned int c_size;
        unsigned int c_tail = base[1];
        if (c_head >= c_tail) {
            c_size = c_head - c_tail;
        } else {
            c_size = c_head + channel->max_size + sizeof(int) - c_tail;
        }
        check_valid_operation(channel_id, CHANNEL_TYPE_NORMAL, 'w');
        for(i=1; i<ARRAYLEN(addressmap); i++)
        {
            if(addressmap[i].task_id != get_mytask_id() &&
                addressmap[i].channel_id == channel_id &&
                addressmap[i].op == 'r')
            {
                i = addressmap[i].task_id;
                break;
            }
        }
        printf("PROC_DEBUG(CH) " PROC_NAME ".%s write %d(to'%s') %d %d/%d start\n", get_task_name(get_mytask_id()), channel_id, get_task_name(i), len, c_size, channel->max_size);
    }
#endif

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    if(len < 0)
    {
        printf("write_port(): len should be larger than 0!\n");
        exit(EXIT_SUCCESS);
    }

    if(len > channel->max_size)
    {
        printf("write_port(): max_size is too small!\n");
        exit(EXIT_FAILURE);
    }
#endif

    do {
        c_tail = base[1];
        if (c_head >= c_tail) {
            c_size = c_head - c_tail;
        } else {
            c_size = c_head + channel->max_size + sizeof(int) - c_tail;
        }
        if ((c_size + len) >= channel->max_size + sizeof(int)) {
                OSSchedUnlock();
                CIC_task_sleep(channel, 'w');
                OSSchedLock();
        }
        else
            break;
    } while (1);

    if ((c_head + len) > channel->max_size + sizeof(int)) {
        unsigned int s1, s2;
        s1 = channel->max_size + sizeof(int) - c_head;
        s2 = len - s1;

        memcpy((char *)(base + 2) + c_head, buf, s1);
        memcpy((char *)(base + 2), buf + s1, s2);
    } else {
        memcpy((char *)(base + 2) + c_head, buf, len);
    }

    c_head += len;
    if (c_head >= channel->max_size + sizeof(int))
        c_head -= channel->max_size + sizeof(int);

    base[0] = c_head;
    CIC_task_notify(channel, 'w');//KJW added

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    {
        int i;
        for(i=1; i<ARRAYLEN(addressmap); i++)
        {
            if(addressmap[i].task_id != get_mytask_id() &&
                addressmap[i].channel_id == channel_id &&
                addressmap[i].op == 'r')
            {
                i = addressmap[i].task_id;
                break;
            }
        }
        printf("PROC_DEBUG(CH) " PROC_NAME ".%s write %d(to'%s') %d %d/%d end\n", get_task_name(get_mytask_id()), channel_id, get_task_name(i), len, c_size + len, channel->max_size);
    }
#endif

    return len;
}

int write_port(int channel_index, unsigned char *buf, int len)
{
    int result = 0;

    while(channel_index >= 0) {
        result = write_one_port(&channels[channel_index],buf,len);
        channel_index = channels[channel_index].next_channel_index;
    }

    return result;
}

int available(int channel_id) // non-blocking
{
    volatile unsigned int *base;
    unsigned int c_head;
    unsigned int c_tail;
    unsigned int c_size;

    CHANNEL *channel;
    channel = &channels[channel_id];

    base = channel->buf;
    c_head = base[0];
    c_tail = base[1];

    if (c_head >= c_tail) {
        c_size = c_head - c_tail;
    } else {
          c_size = c_head + channel->max_size + sizeof(int) - c_tail;
    }
 
    return c_size;
}
##READ_WRITE_PORT_END

##READ_WRITE_AC_PORT_START
int read_acport(int channel_id, unsigned char *buf, int len, int index)
{
    volatile unsigned int *base;

    CHANNEL *channel;
    channel = &channels[channel_id];

    base = (unsigned int *)((unsigned int)channel->buf + index*(sizeof(int)+SIZE_ALIGN(channel->sampleSize)));
    if((unsigned int)base % 4 != 0)
    {
        printf(PROC_NAME ":read_acport(): base should be 4-byte aligned!\n");
        EXIT(1);
    }

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    {
        int i;
        check_valid_operation(channel_id, CHANNEL_TYPE_ARRAY_CHANNEL, 'r');
        for(i=1; i<ARRAYLEN(addressmap); i++)
        {
            if(addressmap[i].task_id != get_mytask_id() &&
                addressmap[i].channel_id == channel_id &&
                addressmap[i].op == 'w')
            {
                i = addressmap[i].task_id;
                break;
            }
        }
        printf("PROC_DEBUG(CH) " PROC_NAME ".%s acread %d(from'%s') %d %d start\n", get_task_name(get_mytask_id()), channel_id, get_task_name(i), len, index);
    }
#endif

#if defined(PARAM_DEBUG) && (PARAM_DEBUG==1)
    if(len != channel->sampleSize)
    {
        printf("read_acport(): len should be %d!\n", channel->sampleSize);
        EXIT(1);
    }

    if(index < 0)
    {
        printf("read_acport(): index should be non-negative!\n");
        EXIT(1);
    }

    if(index >= channel->max_size/channel->sampleSize)
    {
        printf("read_acport(): index is too large!\n");
        exit(EXIT_FAILURE);
    }
#endif

    do {
        int avail;
        avail = base[0];
        if(avail == 0)
        {
            OSSchedUnlock();
            CIC_task_sleep(channel, 'r');
            OSSchedLock();
        }
        else if(avail == 1 || avail == 2)
        {
            break;
        }
        else
        {
            printf(PROC_NAME ":read_acport():unknown status\n");
            EXIT(1);
        }
    } while(1);

    memcpy(buf, (void *)&base[1], channel->sampleSize);
    base[0] = 0;

    // TODO
    // notify?
    CIC_task_notify(channel, 'r');

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    {
        int i;
        for(i=1; i<ARRAYLEN(addressmap); i++)
        {
            if(addressmap[i].task_id != get_mytask_id() &&
                addressmap[i].channel_id == channel_id &&
                addressmap[i].op == 'w')
            {
                i = addressmap[i].task_id;
                break;
            }
        }
        printf("PROC_DEBUG(CH) " PROC_NAME ".%s acread %d(from'%s') %d %d start\n", get_task_name(get_mytask_id()), channel_id, get_task_name(i), len, index);
    }
#endif

    return len;
}

int write_acport(int channel_id, unsigned char *buf, int len, int index)
{
    volatile unsigned int *base;

    CHANNEL *channel;
    channel = &channels[channel_id];

    base = (unsigned int *)((unsigned int)channel->buf + index*(sizeof(int)+SIZE_ALIGN(channel->sampleSize)));
    if((unsigned int)base % 4 != 0)
    {
        printf(PROC_NAME ":write_acport(): base should be 4-byte aligned!\n");
        EXIT(1);
    }

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    {
        int i;
        check_valid_operation(channel_id, CHANNEL_TYPE_ARRAY_CHANNEL, 'w');
        for(i=1; i<ARRAYLEN(addressmap); i++)
        {
            if(addressmap[i].task_id != get_mytask_id() &&
                addressmap[i].channel_id == channel_id &&
                addressmap[i].op == 'r')
            {
                i = addressmap[i].task_id;
                break;
            }
        }
        printf("PROC_DEBUG(CH) " PROC_NAME ".%s acwrite %d(from'%s') %d %d start\n", get_task_name(get_mytask_id()), channel_id, get_task_name(i), len, index);
    }
#endif

#if defined(PARAM_DEBUG) && (PARAM_DEBUG==1)
    if(len != channel->sampleSize)
    {
        printf("write_acport(): len should be %d!\n", channel->sampleSize);
        EXIT(1);
    }

    if(index < 0)
    {
        printf("write_acport(): index should be non-negative!\n");
        EXIT(1);
    }

    if(index >= channel->max_size/channel->sampleSize)
    {
        printf("write_acport(): index is too large!\n");
        exit(EXIT_FAILURE);
    }
#endif

    do {
        int avail;
        avail = base[0];
        if(avail == 1 || avail == 2)
        {
            OSSchedUnlock();
            CIC_task_sleep(channel, 'w');
            OSSchedLock();
        }
        else if(avail == 0)
        {
            break;
        }
        else
        {
            printf(PROC_NAME ":write_acport():unknown status\n");
            EXIT(1);
        }
    } while(1);

    memcpy((void *)&base[1], buf, channel->sampleSize);
    base[0] = 1;

    // TODO
    // notify?
    CIC_task_notify(channel, 'w');

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    {
        int i;
        for(i=1; i<ARRAYLEN(addressmap); i++)
        {
            if(addressmap[i].task_id != get_mytask_id() &&
                addressmap[i].channel_id == channel_id &&
                addressmap[i].op == 'r')
            {
                i = addressmap[i].task_id;
                break;
            }
        }
        printf("PROC_DEBUG(CH) " PROC_NAME ".%s acwrite %d(from'%s') %d %d start\n", get_task_name(get_mytask_id()), channel_id, get_task_name(i), len, index);
    }
#endif

    return len;
}

int ac_available (int channel_id, int index)
{
    printf("ac_available(): not implemented yet....\n");
    EXIT(1);

    // TODO
    ;
    return 1;
}

int check_acport(int channel_id)
{
    // TODO
    int i;

    volatile unsigned int *base;

    CHANNEL *channel;
    channel = &channels[channel_id];

check_ac_start:

    OS_ENTER_CRITICAL();
    lock_acquire();

    for(i=0;i<(channel->max_size/channel->sampleSize);i++)
    {
        int avail;
        base = (unsigned int *)((unsigned int)channel->buf + i*(sizeof(int)+SIZE_ALIGN(channel->sampleSize)));
        avail = base[0];
        if(avail == 1)
        {
            base[0] = 2;
            lock_release();
            return i;
        }
    }

    lock_release();
    OS_EXIT_CRITICAL();

    OSSchedUnlock();
    CIC_task_sleep(channel, 'r');
    OSSchedLock();

    goto check_ac_start;
}
##READ_WRITE_AC_PORT_END

##READ_WRITE_BUF_PORT_START
int read_buf_port(int channel_index, unsigned char *buf, int len)
{
    volatile unsigned int *base;
//    unsigned int c_head;
    unsigned int c_tail;
//    unsigned int c_size;

    CHANNEL *channel;
    channel = &channels[channel_index];

    base = channel->buf;
    c_tail = base[1];

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    {
        int i;
        unsigned int c_size;
        unsigned int c_head = base[0];
        if (c_head >= c_tail) {
            c_size = c_head - c_tail;
        } else {
            c_size = c_head + channel->max_size + sizeof(int) - c_tail;
        }
        check_valid_operation(channel_id, CHANNEL_TYPE_NORMAL, 'r');
        for(i=1; i<ARRAYLEN(addressmap); i++)
        {
            if(addressmap[i].task_id != get_mytask_id() &&
                addressmap[i].channel_id == channel_id &&
                addressmap[i].op == 'w')
            {
                i = addressmap[i].task_id;
                break;
            }
        }
        printf("PROC_DEBUG(CH) " PROC_NAME ".%s read %d(from'%s') %d %d/%d start\n", get_task_name(get_mytask_id()), channel_id, get_task_name(i), len, c_size, channel->max_size);
    }
#endif

#if defined(PARAM_DEBUG) && (PARAM_DEBUG==1)
    if(len < 0)
    {
        printf("%d %d\n", channel_id, len);
        printf("read_port(): len should be larger than 0!\n");
        exit(EXIT_SUCCESS);
    }

    if(len > channel->max_size)
    {
        printf("read_port(): max_size is too small!\n");
        exit(EXIT_FAILURE);
    }
#endif

    if ((c_tail + len) > channel->max_size + sizeof(int)) {
        unsigned int s1, s2;
        s1 = channel->max_size + sizeof(int) - c_tail;
        s2 = len - s1;

        memcpy(buf, (char *)(base + 2) + c_tail, s1);
        memcpy(buf + s1, (char *)(base + 2), s2);
    } else {
        memcpy(buf, (char *)(base + 2) + c_tail, len);
    }
/*
    c_tail += len;
    if (c_tail >= channel->max_size + sizeof(int))
        c_tail -= channel->max_size + sizeof(int);
*/
    base[1] = c_tail;

    CIC_task_notify(channel, 'r');//KJW added

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    {
        int i;
        for(i=1; i<ARRAYLEN(addressmap); i++)
        {
            if(addressmap[i].task_id != get_mytask_id() &&
                addressmap[i].channel_id == channel_id &&
                addressmap[i].op == 'w')
            {
                i = addressmap[i].task_id;
                break;
            }
        }
        printf("PROC_DEBUG(CH) " PROC_NAME ".%s read %d(from'%s') %d %d/%d end\n", get_task_name(get_mytask_id()), channel_id, get_task_name(i), len, c_size - len, channel->max_size);
    }
#endif

    return len;
}

int write_one_buf_port(CHANNEL* channel, unsigned char *buf, int len)
{
    volatile unsigned int *base;
    unsigned int c_head;
//    unsigned int c_tail;
//    unsigned int c_size;

    base = channel->buf;
    c_head = base[0];

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    {
        int i;
        unsigned int c_size;
        unsigned int c_tail = base[1];
        if (c_head >= c_tail) {
            c_size = c_head - c_tail;
        } else {
            c_size = c_head + channel->max_size + sizeof(int) - c_tail;
        }
        check_valid_operation(channel_id, CHANNEL_TYPE_NORMAL, 'w');
        for(i=1; i<ARRAYLEN(addressmap); i++)
        {
            if(addressmap[i].task_id != get_mytask_id() &&
                addressmap[i].channel_id == channel_id &&
                addressmap[i].op == 'r')
            {
                i = addressmap[i].task_id;
                break;
            }
        }
        printf("PROC_DEBUG(CH) " PROC_NAME ".%s write %d(to'%s') %d %d/%d start\n", get_task_name(get_mytask_id()), channel_id, get_task_name(i), len, c_size, channel->max_size);
    }
#endif

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    if(len < 0)
    {
        printf("write_port(): len should be larger than 0!\n");
        exit(EXIT_SUCCESS);
    }

    if(len > channel->max_size)
    {
        printf("write_port(): max_size is too small!\n");
        exit(EXIT_FAILURE);
    }
#endif

    if ((c_head + len) > channel->max_size + sizeof(int)) {
        unsigned int s1, s2;
        s1 = channel->max_size + sizeof(int) - c_head;
        s2 = len - s1;

        memcpy((char *)(base + 2) + c_head, buf, s1);
        memcpy((char *)(base + 2), buf + s1, s2);
    } else {
        memcpy((char *)(base + 2) + c_head, buf, len);
    }
/*
    c_head += len;
    if (c_head >= channel->max_size + sizeof(int))
        c_head -= channel->max_size + sizeof(int);
*/
    base[0] = c_head;
    CIC_task_notify(channel, 'w');//KJW added

#if defined(PROC_DEBUG) && (PROC_DEBUG==1)
    {
        int i;
        for(i=1; i<ARRAYLEN(addressmap); i++)
        {
            if(addressmap[i].task_id != get_mytask_id() &&
                addressmap[i].channel_id == channel_id &&
                addressmap[i].op == 'r')
            {
                i = addressmap[i].task_id;
                break;
            }
        }
        printf("PROC_DEBUG(CH) " PROC_NAME ".%s write %d(to'%s') %d %d/%d end\n", get_task_name(get_mytask_id()), channel_id, get_task_name(i), len, c_size + len, channel->max_size);
    }
#endif

    return len;
}

int write_buf_port(int channel_index, unsigned char *buf, int len)
{
    int result = 0;

    while(channel_index >= 0) {
        result = write_one_buf_port(&channels[channel_index],buf,len);
        channel_index = channels[channel_index].next_channel_index;
    }

    return result;
}
##READ_WRITE_BUF_PORT_END