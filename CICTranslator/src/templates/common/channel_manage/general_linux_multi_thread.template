##INIT_WRAPUP_CHANNELS_START

CIC_STATIC CIC_T_VOID InitChannel(CIC_T_INT channel_index)
{
	CIC_T_INT i = channel_index;
	CIC_F_MUTEX_INIT(&(channels[i].mutex));
    CIC_F_COND_INIT(&(channels[i].cond));

    if(channels[i].type == CIC_UT_CHANNEL_TYPE_NORMAL || channels[i].type == CIC_UT_CHANNEL_TYPE_BUFFER){
        CIC_UT_BUFFER_DATA_TYPE ptr;
        ptr = (CIC_UT_BUFFER_DATA_TYPE)CIC_F_MEM_ALLOC(channels[i].max_size);
        if(ptr == CIC_V_NULL){
            CIC_F_ERROR("proc", "InitChannels(): MEM_ALLOC failed!", CIC_V_ERROR_EXIT);
        }
        CIC_F_MEM_SET(ptr, 0x0, channels[i].init_data);
        channels[i].buf = ptr;
        channels[i].start = ptr;
        channels[i].end = ptr + channels[i].init_data;
        channels[i].cur_size = channels[i].init_data;
    }
    else if(channels[i].type == CIC_UT_CHANNEL_TYPE_ARRAY_CHANNEL){
        if(channels[i].max_size <= 0)
         	CIC_F_ERROR("proc", "InitChannels(): max_size should be positive!", CIC_V_ERROR_EXIT);

        if(channels[i].sample_size <= 0)
       		CIC_F_ERROR("proc", "InitChannels(): sample_size should be positive!", CIC_V_ERROR_EXIT);

        if(channels[i].max_size % channels[i].sample_size != 0)
        	CIC_F_ERROR("proc", "InitChannels(): max_size should be divided by sample_size!", CIC_V_ERROR_EXIT);

        CIC_T_INT j;
        CIC_CONST CIC_T_INT count = channels[i].max_size / channels[i].sample_size;
        channels[i].head = (CIC_UT_AC_DATA*) CIC_F_MEM_ALLOC(count * CIC_SIZEOF(CIC_UT_AC_DATA));
        if(channels[i].head == CIC_V_NULL){
            CIC_F_ERROR("proc", "InitChannels(): MEM_ALLOC failed!", CIC_V_ERROR_EXIT);
        }

        channels[i].avail_index_start = channels[i].avail_index_end = CIC_V_NULL;

        for(j=0;j<count;j++){
            channels[i].head[j].avail_node = (CIC_UT_AC_AVAIL_LIST*) CIC_F_MEM_ALLOC(CIC_SIZEOF(CIC_UT_AC_AVAIL_LIST));
            if(channels[i].head[j].avail_node == CIC_V_NULL){
                CIC_F_ERROR("proc", "InitChannels(): MEM_ALLOC failed!", CIC_V_ERROR_EXIT);
            }
            channels[i].head[j].avail_node->avail_index = j;
            channels[i].head[j].avail_node->prev = channels[i].head[j].avail_node->next = CIC_V_NULL;

            if(j< (channels[i].init_data/channels[i].sample_size)){
                channels[i].head[j].used = 1;
                CIC_UT_AC_DATA *ptr;
                CIC_UT_CHANNEL *channel;
                ptr = &(channels[i].head[j]);
                channel = &(channels[i]);
                if(channel->avail_index_start == CIC_V_NULL){
                    channel->avail_index_start = channel->avail_index_end = ptr->avail_node;
                }
                else{
                    CIC_UT_AC_AVAIL_LIST *node;
                    node = channel->avail_index_end;
                    channel->avail_index_end = node->next = ptr->avail_node;
                    ptr->avail_node->prev = node;
                    ptr->avail_node->next = CIC_V_NULL;
                }
            }
            else{
                channels[i].head[j].used = 0;
            }
            channels[i].head[j].buf = CIC_F_MEM_ALLOC(channels[i].sample_size);
            if(channels[i].head[j].buf == CIC_V_NULL){
               CIC_F_ERROR("proc", "InitChannels(): MEM_ALLOC failed!", CIC_V_ERROR_EXIT);
            }
        }
    }
}

CIC_STATIC CIC_T_VOID InitChannels(CIC_T_VOID)
{
    CIC_T_UINT i;
    for(i=0; i<CIC_UV_NUM_CHANNELS; i++){
        InitChannel(i);
    }
}

CIC_STATIC CIC_T_VOID WrapupChannel(CIC_T_INT channel_index)
{
	CIC_T_INT i = channel_index;
	if(channels[i].type == CIC_UT_CHANNEL_TYPE_NORMAL || channels[i].type == CIC_UT_CHANNEL_TYPE_BUFFER){
        if(channels[i].buf != CIC_V_NULL){
        	CIC_F_MEM_FREE(channels[i].buf);
			channels[i].buf = CIC_V_NULL;
		}
    }
    else if(channels[i].type == CIC_UT_CHANNEL_TYPE_ARRAY_CHANNEL){
        CIC_T_INT j;
        
		if(channels[i].head != CIC_V_NULL){
			CIC_CONST CIC_T_INT count = channels[i].max_size / channels[i].sample_size;
			for(j=0;j<count;j++){
				if(channels[i].head[j].avail_node != CIC_V_NULL){
					CIC_F_MEM_FREE(channels[i].head[j].avail_node);
					channels[i].head[j].avail_node = CIC_V_NULL;
				}
				if(channels[i].head[j].buf != CIC_V_NULL){
					CIC_F_MEM_FREE(channels[i].head[j].buf);
					channels[i].head[j].buf = CIC_V_NULL;
				}
			}
			CIC_F_MEM_FREE(channels[i].head);
			channels[i].head = CIC_V_NULL;
		}
	}
}

CIC_STATIC CIC_T_VOID WrapupChannels(CIC_T_VOID)
{
    CIC_T_UINT i;
    for(i=0; i<CIC_UV_NUM_CHANNELS; i++){
        WrapupChannel(i);
    }
}
##INIT_WRAPUP_CHANNELS_END

##INIT_WRAPUP_TASK_CHANNELS_START
CIC_STATIC CIC_T_VOID InitTaskChannels(CIC_T_INT parent_task_id){
    CIC_T_INT i=0, j=0, count=0;
    for(i=0; i<CIC_UV_NUM_CHANNELS; i++){
        count = 0;
        for(j=0; j< CIC_UV_NUM_PORTMAPS; j++){
            if(channels[i].channel_id == addressmap[j].channel_id 
            	&& tasks[addressmap[j].task_id].parent_task_id == parent_task_id) count++;
        }
        if(count == 2){
            InitChannel(i);
        }
    }
}

CIC_STATIC CIC_T_VOID WrapupTaskChannels(CIC_T_INT parent_task_id){
CIC_T_INT i=0, j=0, count=0;
    for(i=0; i<CIC_UV_NUM_CHANNELS; i++){
        count = 0;
        for(j=0; j< CIC_UV_NUM_PORTMAPS; j++){
            if(channels[i].channel_id == addressmap[j].channel_id 
            	&& tasks[addressmap[j].task_id].parent_task_id == parent_task_id) count++;
        }
        if(count == 2){
            WrapupChannel(i);
        }
    }
}
##INIT_WRAPUP_TASK_CHANNELS_END

##READ_WRITE_PORT_START
CIC_T_INT ReadPort(CIC_T_INT channel_index, CIC_UT_BUFFER_DATA_TYPE buf, CIC_T_INT len) // blocking
{
    CIC_T_INT cur_size=0;
    CIC_T_INT channel_id = channels[channel_index].channel_id;
    CIC_T_INT task_id = GetTaskIdFromChannelIdAndOp(channel_id, 'r');
    CIC_T_INT task_index = GetTaskIndexFromTaskId(task_id);
    CIC_UT_CHANNEL *channel = &channels[channel_index];
    
    if(len < 0){
        CIC_T_CHAR task_channel_name[255], channel_id_name[10];
        CIC_F_INTEGER_TO_STRING(channel_id_name, channel_id);
        CIC_F_STRING_COPY(task_channel_name, tasks[task_id].name);
        CIC_F_STRING_CONCATENATE(task_channel_name, ", ");
        CIC_F_STRING_CONCATENATE(task_channel_name, channel_id_name);
    	CIC_F_ERROR(task_channel_name, "ReadPort(): len should be larger than 0!", CIC_V_ERROR_EXIT);
    }

    if(len > channel->max_size){
        CIC_T_CHAR task_channel_name[255], channel_id_name[10];
        CIC_F_INTEGER_TO_STRING(channel_id_name, channel_id);
        CIC_F_STRING_COPY(task_channel_name, tasks[task_id].name);
        CIC_F_STRING_CONCATENATE(task_channel_name, ", ");
        CIC_F_STRING_CONCATENATE(task_channel_name, channel_id_name);
   		CIC_F_ERROR(task_channel_name, "ReadPort(): max_size is too small!", CIC_V_ERROR_EXIT);
    }

	CIC_F_MUTEX_LOCK(&(channel->mutex));
read_start:
	if(tasks[task_id].state == STATE_STOP) {
		len = 0;
		CIC_F_MUTEX_UNLOCK(&(channel->mutex));
        goto _EXIT;
    }

    if(channel->start < channel->end){
    	cur_size = (CIC_T_UINT)(channel->end - channel->start);
    }
    else if(channel->start == channel->end){
    	if(channel->is_full)		cur_size = channel->max_size;
     	else						cur_size = 0;
    }
    else  cur_size = (CIC_T_UINT)(channel->end + channel->max_size - channel->start);

    if(len > cur_size){ 	// blocking case
    	if(task_id >= 0)	tasks[task_id].run_state = READ_BLOCK;
        CIC_F_COND_WAIT(&(channel->cond), &(channel->mutex));
        goto read_start; 	// try reading again
    }
    else CIC_F_MUTEX_UNLOCK(&(channel->mutex));

	if(task_id >= 0)	tasks[task_id].run_state = RUNNING;

    if(channel->start + len <= channel->buf + channel->max_size){
        CIC_F_MEM_COPY(buf, channel->start, len);
        
        channel->start += len;
        if(channel->end == channel->start)	channel->is_full = CIC_V_FALSE;
        CIC_F_COND_BROADCAST(&(channel->cond));
    }
    else{
        CIC_T_INT part = channel->max_size - (channel->start - channel->buf);
        if(part != 0)	CIC_F_MEM_COPY(buf, channel->start, part);
        CIC_F_MEM_COPY(buf + part, channel->buf, len - part);
        
        channel->start = channel->buf + (len - part);
        if(channel->end == channel->start)	channel->is_full = CIC_V_FALSE;
        CIC_F_COND_BROADCAST(&(channel->cond));
    }
	CIC_F_MUTEX_UNLOCK(&(channel->mutex));  
_EXIT:
    return len;
}

CIC_T_INT WriteOnePort(CIC_T_INT channel_index, CIC_UT_BUFFER_DATA_TYPE buf, CIC_T_INT len) // blocking
{
    CIC_T_INT cur_size=0;
    CIC_T_INT channel_id = channels[channel_index].channel_id;
    CIC_T_INT task_id = GetTaskIdFromChannelIdAndOp(channel_id, 'r');
	CIC_T_INT src_task_id = GetTaskIdFromChannelIdAndOp(channel_id, 'w');
    CIC_T_INT task_index = GetTaskIndexFromTaskId(task_id);
    CIC_UT_CHANNEL *channel = &channels[channel_index];
    
    if(len < 0){
        CIC_T_CHAR task_channel_name[255], channel_id_name[10];
        CIC_F_INTEGER_TO_STRING(channel_id_name, channel_id);
        CIC_F_STRING_COPY(task_channel_name, tasks[task_id].name);
        CIC_F_STRING_CONCATENATE(task_channel_name, ", ");
        CIC_F_STRING_CONCATENATE(task_channel_name, channel_id_name);
    	CIC_F_ERROR(task_channel_name, "WriteOnePort(): len should be larger than 0!", CIC_V_ERROR_EXIT);
    }

    if(len > channel->max_size){
        CIC_T_CHAR task_channel_name[255], channel_id_name[10];
        CIC_F_INTEGER_TO_STRING(channel_id_name, channel_id);
        CIC_F_STRING_COPY(task_channel_name, tasks[task_id].name);
        CIC_F_STRING_CONCATENATE(task_channel_name, ", ");
        CIC_F_STRING_CONCATENATE(task_channel_name, channel_id_name);
   		CIC_F_ERROR(task_channel_name, "WriteOnePort(): max_size is too small!", CIC_V_ERROR_EXIT);
    }

	CIC_F_MUTEX_LOCK(&(channel->mutex));
write_start:

	if(tasks[src_task_id].state == STATE_STOP){
		len  = 0;
    	CIC_F_MUTEX_UNLOCK(&(channel->mutex));
		goto _EXIT;
	}

    if(channel->start < channel->end){
    	cur_size = (CIC_T_UINT)(channel->end - channel->start);
    }
    else if(channel->start == channel->end){
      if(channel->is_full)		cur_size = channel->max_size;
      else 						cur_size = 0;
    }
    else{
    	cur_size = (CIC_T_UINT)(channel->end + channel->max_size - channel->start);
	}
	
    if(len + cur_size > channel->max_size){ 	// blocking case
        if(task_id >= 0)	tasks[task_id].run_state = WRITE_BLOCK;
        CIC_F_COND_WAIT(&(channel->cond), &(channel->mutex));
        goto write_start; 						// try writing again
    }
    
    if(task_id >= 0)	tasks[task_id].run_state = RUNNING;

    if(channel->buf + channel->max_size >= channel->end + len){
        CIC_F_MEM_COPY(channel->end, buf, len);
        
        channel->end += len;
        if(channel->end == channel->start)	channel->is_full = CIC_V_TRUE;
        CIC_F_COND_BROADCAST(&(channel->cond));
    }
    else{
        CIC_T_INT part = channel->max_size - (channel->end - channel->buf);
        if(part != 0){
            CIC_F_MEM_COPY(channel->end, buf, part);
        }
        CIC_F_MEM_COPY(channel->buf, buf + part, len - part);
        
        channel->end = channel->buf + (len - part);
        if(channel->end == channel->start)	channel->is_full = CIC_V_TRUE;
        CIC_F_COND_BROADCAST(&(channel->cond));
    }   
 	CIC_F_MUTEX_UNLOCK(&(channel->mutex));
   
#if defined(BREAK_DEBUG) && (BREAK_DEBUG==1)
    if(channel->is_break){
    	DumpBreakChannelData(channel_id);
		WaitFromGUIBreak();
		UpdateBreak();
    }
#endif

#if defined(WATCH_DEBUG) && (WATCH_DEBUG==1)
    if(channel->is_watch){
    	DumpWatchChannelData(channel_id);
		UpdateWatch();
    }
#endif
_EXIT:
    return len;
}

CIC_T_INT WritePort(CIC_T_INT channel_index, CIC_UT_BUFFER_DATA_TYPE buf, CIC_T_INT len)
{
    CIC_T_INT result = 0;
    CIC_T_INT next_channel_id = 0;

    while(channel_index >= 0) {
        result = WriteOnePort(channel_index, buf, len);
        next_channel_id = channels[channel_index].next_channel_id;
        if(next_channel_id >= 0)        channel_index = GetChannelIndexFromChannelId(next_channel_id);
        else                            channel_index = -1;
    }

    return result;
}

// Non-blocking check
CIC_T_INT Available(CIC_T_INT channel_index)
{
    CIC_T_INT ret;

    CIC_UT_CHANNEL *channel = &channels[channel_index];

    CIC_F_MUTEX_LOCK(&(channel->mutex));

    if(channel->start <= channel->end) {
    	ret = (CIC_T_UINT)(channel->end - channel->start);
    	if(ret == 0 && channel->is_full == CIC_V_TRUE)	ret = channel->max_size;
    } 
    else{
    	ret = (CIC_T_UINT)(channel->end + channel->max_size - channel->start);
    }

    CIC_F_MUTEX_UNLOCK(&(channel->mutex));

    return ret;
}
##READ_WRITE_PORT_END


##READ_WRITE_AC_PORT_START
CIC_T_INT ReadACPort(CIC_T_INT channel_index, CIC_UT_BUFFER_DATA_TYPE buf, CIC_T_INT len, CIC_T_INT index)
{
    CIC_UT_AC_DATA *ptr;
    CIC_T_INT channel_id = channels[channel_index].channel_id;
    CIC_UT_CHANNEL *channel = &channels[channel_index];
    CIC_T_INT task_id = GetTaskIdFromChannelIdAndOp(channel_index, 'r');
    ptr = &channel->head[index];
    
read_ac_start:
    CIC_F_MUTEX_LOCK(&(channel->mutex));

    if(ptr->used == 0){
        channel->request_read = CIC_V_TRUE;
        if(task_id >= 0){
    		tasks[task_id].run_state = READ_BLOCK;
    	}
        if(channel->request_write == CIC_V_TRUE){
            CIC_T_CHAR task_channel_name[255], channel_id_name[10];
            CIC_F_INTEGER_TO_STRING(channel_id_name, channel_id);
            CIC_F_STRING_COPY(task_channel_name, tasks[task_id].name);
            CIC_F_STRING_CONCATENATE(task_channel_name, ", ");
            CIC_F_STRING_CONCATENATE(task_channel_name, channel_id_name);
        	CIC_F_ERROR(task_channel_name, "ReadACPort(): deadlock!", CIC_V_ERROR_EXIT);
        }
        CIC_F_COND_WAIT(&(channel->cond), &(channel->mutex));
        CIC_F_MUTEX_UNLOCK(&(channel->mutex));
        goto read_ac_start;
    }
    if(task_id >= 0)	tasks[task_id].run_state = RUNNING;
    channel->request_read = CIC_V_FALSE;

    CIC_F_MEM_COPY(buf, ptr->buf, len);

    CIC_UT_AC_AVAIL_LIST *node;
    node = ptr->avail_node;

	if(ptr->used != 2){
        if(node->prev != CIC_V_NULL){
            node->prev->next = node->next;
        }
        else{
            channel->avail_index_start = node->next;
        }
        if(node->next != CIC_V_NULL){
            node->next->prev = node->prev;
        }
        else{
            channel->avail_index_end = node->prev;
        }
        //node->prev = node->next = CIC_V_NULL;
    }

    ptr->used = 0;

    CIC_F_MUTEX_UNLOCK(&(channel->mutex));
    CIC_F_COND_BROADCAST(&(channel->cond));

    return len;
}

CIC_T_INT WriteACPort(CIC_T_INT channel_index, CIC_UT_BUFFER_DATA_TYPE buf, CIC_T_INT len, CIC_T_INT index)
{
    CIC_UT_AC_DATA *ptr;
    CIC_T_INT channel_id = channels[channel_index].channel_id;
	CIC_T_INT task_id = GetTaskIdFromChannelIdAndOp(channel_index, 'w');
    CIC_UT_CHANNEL *channel = &channels[channel_index];

    ptr = &channel->head[index];

write_ac_start:

    CIC_F_MUTEX_LOCK(&(channel->mutex));

    if(ptr->used != 0){
        channel->request_write = CIC_V_TRUE;
        if(task_id >= 0)	tasks[task_id].run_state = WRITE_BLOCK;
        if(channel->request_read == CIC_V_TRUE){
            CIC_T_CHAR task_channel_name[255], channel_id_name[10];
            CIC_F_INTEGER_TO_STRING(channel_id_name, channel_id);
            CIC_F_STRING_COPY(task_channel_name, tasks[task_id].name);
            CIC_F_STRING_CONCATENATE(task_channel_name, ", ");
            CIC_F_STRING_CONCATENATE(task_channel_name, channel_id_name);
            CIC_F_ERROR(task_channel_name, "WriteACPort(): deadlock!", CIC_V_ERROR_EXIT);
        }
         CIC_F_COND_WAIT(&(channel->cond), &(channel->mutex));
         CIC_F_MUTEX_UNLOCK(&(channel->mutex));
        goto write_ac_start;
    }
    if(task_id >= 0)	tasks[task_id].run_state = RUNNING;
    channel->request_write = CIC_V_FALSE;

    memcpy(ptr->buf, buf, len);
    ptr->used = 1;
    
#if defined(BREAK_DEBUG) && (BREAK_DEBUG==1)
    if(channel->is_break){
    	DumpBreakChannelData(channel_id);
    	WaitFromGUIBreak();
    	UpdateBreak();
    }
#endif

#if defined(WATCH_DEBUG) && (WATCH_DEBUG==1)
    if(channel->is_watch){
    	DumpWatchChannelData(channel_id);
        UpdateWatch();
    }
#endif

    if(channel->avail_index_start == CIC_V_NULL){
        channel->avail_index_start = channel->avail_index_end = ptr->avail_node;
    }
    else{
        CIC_UT_AC_AVAIL_LIST *node;
        node = channel->avail_index_end;
        channel->avail_index_end = node->next = ptr->avail_node;
        ptr->avail_node->prev = node;
        ptr->avail_node->next = CIC_V_NULL;
    }

    CIC_F_MUTEX_UNLOCK(&(channel->mutex));
    CIC_F_COND_BROADCAST(&(channel->cond));

    return len;
}

CIC_T_INT ACAvailable (CIC_T_INT channel_index, CIC_T_INT index)
{
    CIC_UT_CHANNEL *channel = &channels[channel_index];

    if(channel->head[index].used != 0){
        return 1;
    }
    else if(channel->head[index].used == 0){
        return 0;
    }
    else{
        CIC_T_INT channel_id = channels[channel_index].channel_id;
        CIC_T_CHAR channel_id_name[10];
        CIC_F_INTEGER_TO_STRING(channel_id_name, channel_id);
    	CIC_F_ERROR(channel_id_name, "ACAvailable(): unknown status!", CIC_V_ERROR_EXIT);
    }
}

CIC_T_INT CheckACPort(CIC_T_INT channel_index)
{
    CIC_T_INT ret = -1;

    CIC_UT_CHANNEL *channel = &channels[channel_index];
    CIC_T_INT channel_id = channels[channel_index].channel_id;
    CIC_T_INT task_id = GetTaskIdFromChannelIdAndOp(channel_id, 'r'); 

check_ac_start:

    CIC_F_MUTEX_LOCK(&(channel->mutex));

    CIC_UT_AC_AVAIL_LIST *node;
    node = channel->avail_index_start;

    if(node == CIC_V_NULL){	 // blocking case
    	tasks[task_id].run_state = READ_BLOCK;
        CIC_F_COND_WAIT(&(channel->cond), &(channel->mutex));
        CIC_F_MUTEX_UNLOCK(&(channel->mutex));
        tasks[task_id].run_state = RUNNING;
        goto check_ac_start;
    }
    else{
        ret = node->avail_index;
        channel->avail_index_start = channel->avail_index_start->next;

        if(channel->avail_index_start != CIC_V_NULL){
            channel->avail_index_start->prev = CIC_V_NULL;
        }
        else{
            channel->avail_index_end = CIC_V_NULL;
        }
        node->next = CIC_V_NULL;
        channel->head[ret].used = 2;
    }

    CIC_F_MUTEX_UNLOCK(&(channel->mutex));

    return ret;
}
##READ_WRITE_AC_PORT_END


##READ_WRITE_BUF_PORT_START
CIC_T_INT ReadBufPort(CIC_T_INT channel_index, CIC_UT_BUFFER_DATA_TYPE buf, CIC_T_INT len) // blocking
{
    CIC_T_INT task_id = GetTaskIdFromChannelIdAndOp(channel_index, 'r');    
    CIC_T_INT channel_id = channels[channel_index].channel_id;
    CIC_UT_CHANNEL *channel = &channels[channel_index];

	if(task_id >= 0)	tasks[task_id].run_state = RUNNING;

	CIC_F_MUTEX_LOCK(&(channel->mutex));
    if(channel->buf + len <= channel->buf + channel->max_size){
        CIC_F_MEM_COPY(buf, channel->buf, len);
    }
    else{
        CIC_T_CHAR task_channel_name[255], channel_id_name[10];
        CIC_F_INTEGER_TO_STRING(channel_id_name, channel_id);
        CIC_F_STRING_COPY(task_channel_name, tasks[task_id].name);
        CIC_F_STRING_CONCATENATE(task_channel_name, ", ");
        CIC_F_STRING_CONCATENATE(task_channel_name, channel_id_name);
    	CIC_F_ERROR(task_channel_name, "ReadBufPort(): buf_size < read_size!", CIC_V_ERROR_EXIT);
    }
    CIC_F_MUTEX_UNLOCK(&(channel->mutex));

    return len;
}

CIC_T_INT WriteOneBufPort(CIC_T_INT channel_index, CIC_UT_BUFFER_DATA_TYPE buf, CIC_T_INT len)
{
	CIC_T_INT channel_id = channels[channel_index].channel_id;
    CIC_UT_CHANNEL *channel = &channels[channel_index];
    CIC_T_INT task_id = GetTaskIdFromChannelIdAndOp(channel->channel_id, 'w');

	if(task_id >= 0)	tasks[task_id].run_state = RUNNING;

	CIC_F_MUTEX_LOCK(&(channel->mutex));
    if(channel->buf + channel->max_size >= channel->buf + len){
        CIC_F_MEM_COPY(channel->buf, buf, len);
    }
    else{
        CIC_T_CHAR task_channel_name[255], channel_id_name[10];
        CIC_F_INTEGER_TO_STRING(channel_id_name, channel_id);
        CIC_F_STRING_COPY(task_channel_name, tasks[task_id].name);
        CIC_F_STRING_CONCATENATE(task_channel_name, ", ");
        CIC_F_STRING_CONCATENATE(task_channel_name, channel_id_name);
    	CIC_F_ERROR(task_channel_name, "WriteOneBufPort(): buf_size < write_size!", CIC_V_ERROR_EXIT);
    }
    CIC_F_MUTEX_UNLOCK(&(channel->mutex));
    
#if defined(BREAK_DEBUG) && (BREAK_DEBUG==1)
    if(channel->is_break){
    	DumpBreakChannelData(channel_id);
    	WaitFromGUIBreak();
    	UpdateBreak();
    }
#endif

#if defined(WATCH_DEBUG) && (WATCH_DEBUG==1)
    if(channel->is_watch){
    	DumpWatchChannelData(channel_id);
        UpdateWatch();
    }
#endif

    return len;
}

CIC_T_INT WriteBufPort(CIC_T_INT channel_index, CIC_UT_BUFFER_DATA_TYPE buf, CIC_T_INT len)
{
    CIC_T_INT result = 0;
    CIC_T_INT next_channel_id = 0;

    while(channel_index >= 0) {
        result = WriteOneBufPort(channel_index, buf, len);
        next_channel_id = channels[channel_index].next_channel_id;
        if(next_channel_id >= 0)        channel_index = GetChannelIndexFromChannelId(next_channel_id);
        else                            channel_index = -1;
    }

    return result;
}
##READ_WRITE_BUF_PORT_END