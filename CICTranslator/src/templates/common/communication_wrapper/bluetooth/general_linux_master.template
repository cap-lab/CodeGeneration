##BLUETOOTH_MASTER_START
#include <fcntl.h>
#include <unistd.h>
#include <poll.h>

#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <sys/time.h>

#include <bluetooth/bluetooth.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/sdp.h>
#include <bluetooth/sco.h>
#include <bluetooth/sdp_lib.h>
#include <bluetooth/rfcomm.h>
#include <bluetooth/l2cap.h>


#define MSGSIZE 4

sdp_session_t* register_service(uint8_t rfcomm_channel)
{
  // Adapted from http://www.btessentials.com/examples/bluez/sdp-register.c
  uint32_t svc_uuid_int[] = {   0x01110000, 0x00100000, 0x80000080, 0xFB349B5F };
  const char *service_name = "Roto-Rooter Data Router";
  const char *svc_dsc = "An experimental plumbing router";
  const char *service_prov = "Roto-Rooter";

  uuid_t root_uuid, l2cap_uuid, rfcomm_uuid, svc_uuid,
         svc_class_uuid;
  sdp_list_t *l2cap_list = 0,
             *rfcomm_list = 0,
             *root_list = 0,
             *proto_list = 0,
             *access_proto_list = 0,
             *svc_class_list = 0,
             *profile_list = 0;
  sdp_data_t *channel = 0;
  sdp_profile_desc_t profile;
  sdp_record_t record = { 0 };
  sdp_session_t *session = 0;

  // set the general service ID
  sdp_uuid128_create( &svc_uuid, &svc_uuid_int );
  sdp_set_service_id( &record, svc_uuid );

  char str[256] = "";
  sdp_uuid2strn(&svc_uuid, str, 256);
  printf("Registering UUID %s\n", str);

  // set the service class
  sdp_uuid16_create(&svc_class_uuid, SERIAL_PORT_SVCLASS_ID);
  svc_class_list = sdp_list_append(0, &svc_class_uuid);
  sdp_set_service_classes(&record, svc_class_list);

  // set the Bluetooth profile information
  sdp_uuid16_create(&profile.uuid, SERIAL_PORT_PROFILE_ID);
  profile.version = 0x0100;
  profile_list = sdp_list_append(0, &profile);
  sdp_set_profile_descs(&record, profile_list);

  // make the service record publicly browsable
  sdp_uuid16_create(&root_uuid, PUBLIC_BROWSE_GROUP);
  root_list = sdp_list_append(0, &root_uuid);
  sdp_set_browse_groups( &record, root_list );

  // set l2cap information
  sdp_uuid16_create(&l2cap_uuid, L2CAP_UUID);
  l2cap_list = sdp_list_append( 0, &l2cap_uuid );
  proto_list = sdp_list_append( 0, l2cap_list );

  // register the RFCOMM channel for RFCOMM sockets
  sdp_uuid16_create(&rfcomm_uuid, RFCOMM_UUID);
  channel = sdp_data_alloc(SDP_UINT8, &rfcomm_channel);
  rfcomm_list = sdp_list_append( 0, &rfcomm_uuid );
  sdp_list_append( rfcomm_list, channel );
  sdp_list_append( proto_list, rfcomm_list );

  access_proto_list = sdp_list_append( 0, proto_list );
  sdp_set_access_protos( &record, access_proto_list );

  // set the name, provider, and description
  sdp_set_info_attr(&record, service_name, service_prov, svc_dsc);

  // connect to the local SDP server, register the service record,
  // and disconnect
  session = sdp_connect(BDADDR_ANY, BDADDR_LOCAL, SDP_RETRY_IF_BUSY);
  sdp_record_register(session, &record, 0);

  // cleanup
  sdp_data_free( channel );
  sdp_list_free( l2cap_list, 0 );
  sdp_list_free( rfcomm_list, 0 );
  sdp_list_free( root_list, 0 );
  sdp_list_free( access_proto_list, 0 );
  sdp_list_free( svc_class_list, 0 );
  sdp_list_free( profile_list, 0 );

  return session;
}


THREAD_TYPE bluetoothMasterThread[NUM_BLUETOOTH_CONNECTION];
static int bConnId[NUM_BLUETOOTH_CONNECTION];
static char *address[NUM_BLUETOOTH_CONNECTION];

static int client[NUM_BLUETOOTH_CONNECTION];
static int s[NUM_BLUETOOTH_CONNECTION];
static volatile int currentId = -1;
static MUTEX_TYPE commMutex = MUTEX_INIT_INLINE;
static COND_TYPE commCond = COND_INIT_INLINE;

typedef enum {NONE_CONN, WIFI_CONN, BLUETOOTH_CONN, RF_CONN, I2C_CONN, SERIAL_CONN, UART_CONN, USB_CONN} CONN_TYPE;

typedef struct outgoingConnMap
{
	int lib_or_ch;
	int channel_id;
	CONN_TYPE conn_type;
	int conn_id;
} OUTGOING_CONNECTION_MAP;


static OUTGOING_CONNECTION_MAP connMap[] = {	//need to fix!!! should be take this data from HOPES, not hard-coding 
	//##CONNECTION_MAP_DEFINE
	{1, 0, NONE_CONN, -1},
};

#include "CIC_port.h"
#include "LIB_port.h"

//##NUM_CONNECTION_MAP_DEFINE
static int num_connMap = 1;	//need to fix!!! should be take this data from HOPES, not hard-coding


THREAD_FUNC_RET_TYPE bluetoothMasterRoutine(THREAD_FUNC_ARG_TYPE pdata){
	int id = (int)pdata;
	unsigned char size;
	unsigned char buf[1024] = {0, };
	int i=0, j=0, state=0;
	fd_set fdset;
	struct timeval time;

	time.tv_sec = 0;
	time.tv_usec = 500000;

	while(1){
	/////////////////////////// Receive routine //////////////////////////////////
		FD_ZERO(&fdset);
		FD_SET(bConnId[id], &fdset);
		state = select(bConnId[NUM_BLUETOOTH_CONNECTION-1] + 1, &fdset, NULL, NULL, &time);
	//	state = select(bConnId[id]+1, &fdset, NULL, NULL, &time);
		if(state == -1)
			printf("select FAIL\n");
		if(FD_ISSET(bConnId[id], &fdset)){
			recv(bConnId[id], &size, sizeof(unsigned char), MSG_WAITALL);
			recv(bConnId[id], buf, size, MSG_WAITALL);

			//hshong style
			int channelLibrary = 1;
			/*
			 * jhw style
			int channelLibrary = (int)buf[0];
			int id = (int)buf[4];
			unsigned char *data = &buf[8];

			printf("bluetoothRECv: channelLibray: %d\n", channelLibrary);
			*/

			if(channelLibrary == 0){
/*				if(channels[id].type == CHANNEL_TYPE_NORMAL)
					MQ_SEND(id, data, size - (sizeof(int)*2));
				else if(channels[id].type == CHANNEL_TYPE_BUFFER)
					BUF_SEND(id, data, size - (sizeof(int)*2));
				else if(channels[id].type == CHANNEL_TYPE_ARRAY_CHANNEL){
					// Error handling code
				}
				else{
					// Error handling code
				}
*/
			}
			else if(channelLibrary == 1){
				for(i=0; i<num_libchannels; i++){
					//hshong style
					if(lib_channels[i].op == 'r')
					{
						for(j = 0; j < num_connMap; j++)
						{
							if(connMap[j].lib_or_ch == 1)
							{
								while(1)
								{
									//if(!(connMap[j].conn_type == BLUETOOTH_CONN && connMap[j].conn_id == -1))
									{
										write_lib_port(i, (unsigned char*)buf, lib_channels[i].sampleSize);
										//connMap[j].conn_type = BLUETOOTH_CONN;
										//connMap[j].conn_id = i;
										break;
									}
									//else
									//	SCHED_YIELD();
								}
							}
						}
					}

					/*
					 * jhw style
					if(lib_channels[i].channel_id == id && lib_channels[i].op == 'r'){
						for(j=0; j<num_connMap; j++){
							if(connMap[j].lib_or_ch == 1 && connMap[j].channel_id == id){
								while(1){
									if(!(connMap[j].conn_type == BLUETOOTH_CONN && connMap[j].conn_id == -1)){
										write_lib_port(i, (unsigned char*)data, lib_channels[i].sampleSize);
										connMap[j].conn_type = BLUETOOTH_CONN;
										connMap[j].conn_id = i;
										break;
									}
									else	SCHED_YIELD();
								}
							}
						}
					}
					*/
				}
			}
			else{
				// Error handling code
			}
		}
	///////////////////////////////////////////////////////////////////////////
	
	
	/////////////////////////// Send routine //////////////////////////////////
    	for(j=0; j<num_connMap; j++){
			if(connMap[j].conn_type == BLUETOOTH_CONN){
				if(connMap[j].lib_or_ch == 0){
/*					int ch_id = connMap[j].channel_id;
					if(channels[ch_id].type == CHANNEL_TYPE_NORMAL){
						int cur_size = MQ_AVAILABLE(connMap[j].channel_id);
						if(cur_size >= channels[ch_id].sampleSize){
							memcpy(&buf[0], 0, sizeof(int));
							memcpy(&buf[4], channels[ch_id].channel_id, sizeof(int));
							MQ_RECEIVE(ch_id, &buf[8], channels[ch_id].sampleSize);
							int size = channels[ch_id].sampleSize + (sizeof(int)*2);
							write(bConnId[id], &size, sizeof(unsigned char));
							write(bConnId[id], buf, size);
						}
					}
					else if(channels[ch_id].type == CHANNEL_TYPE_BUFFER){
						int cur_size = MQ_AVAILABLE(connMap[j].channel_id);
						if(cur_size >= channels[ch_id].sampleSize){
							memcpy(&buf[0], 0, sizeof(int));
							memcpy(&buf[4], channels[ch_id].channel_id, sizeof(int));
							BUF_RECEIVE(ch_id, &buf[8], channels[ch_id].sampleSize);
							int size = channels[ch_id].sampleSize + (sizeof(int)*2);
							write(bConnId[id], &size, sizeof(unsigned char));
							write(bConnId[id], buf, size);
						}
					}
					else if(channels[ch_id].type == CHANNEL_TYPE_ARRAY_CHANNEL){
						// Error handling code
					}
*/				}
				else if(connMap[j].lib_or_ch == 1){			//jhw e:: j <-- i
					//hshong style
					int lib_ch_id = init_lib_port(connMap[j].channel_id, 'w');
					int cur_size = LIB_CHECK(lib_ch_id);

					if(cur_size >= lib_channels[lib_ch_id].sampleSize)
					{
						read_lib_port(lib_ch_id, (unsigned char*)buf, lib_channels[lib_ch_id].sampleSize);
						write(bConnId[id], &lib_channels[lib_ch_id].channel_id, sizeof(unsigned char));
						write(bConnId[id], buf, lib_channels[lib_ch_id].sampleSize);
						//connMap[j].conn_type = NONE_CONN;
						//connMap[j].conn_id = -1;
					}

					/*
					 * jhw style
					int lib_ch_id = init_lib_port(connMap[j].channel_id, 'w');
					int cur_size = LIB_CHECK(lib_ch_id);
					if(cur_size >= lib_channels[lib_ch_id].sampleSize){
						memcpy(&buf[0], 1, sizeof(int));
						memcpy(&buf[4], lib_channels[lib_ch_id].channel_id, sizeof(int));
						LIB_RECEIVE(lib_ch_id, &buf[8], lib_channels[lib_ch_id].sampleSize);
						int size = lib_channels[lib_ch_id].sampleSize + (sizeof(int)*2);
						write(bConnId[id], &size, sizeof(unsigned char));		
						write(bConnId[id], buf, size);
						connMap[j].conn_type = NONE_CONN;
						connMap[j].conn_id = -1;
					}
					*/
				}
			}
		}
	///////////////////////////////////////////////////////////////////////////
	}
}

/*
 * previous ver.
THREAD_FUNC_RET_TYPE bluetoothMasterRoutine(THREAD_FUNC_ARG_TYPE pdata){
  unsigned char size;
  unsigned char buf[1024] = {0, };
  int id = (int)pdata;
  int i=0;
  int isWriteEnd = 0, isVoid = 0;

  while(1){
    recv(bConnId[id], &size, sizeof(unsigned char), MSG_WAITALL);
    recv(bConnId[id], buf, size, MSG_WAITALL);

    for(i=0; i<num_libchannels; i++){
      if(lib_channels[i].op == 'r'){
        write_lib_port(i, (unsigned char*)buf, lib_channels[i].sampleSize);   
	  }
	}
	if(lib_channels[i].channel_id == 0){
	    GlobalState_func_data *fdata = (GlobalState_func_data*)buf;
        if(fdata->func_num == 0)	isVoid = 1; 
        if(fdata->func_num == 1)	isVoid = 0; 
        if(fdata->func_num == 2)	isVoid = 0; 
	}

	if(isVoid == 0){
		isWriteEnd = 0;
		while(1){
			for(i=0; i<num_libchannels; i++){
				if(lib_channels[i].op == 'w'){
					int cur_size = 0;
					LIB_CHANNEL *channel = &lib_channels[i];
					if(channel->start < channel->end)  cur_size = (unsigned int)(channel->end - channel->start);
					else if(channel->start == channel->end){
						if(channel->isFull == 0)		 cur_size = 0;
						else if(channel->isFull == 1)	 cur_size = channel->max_size;
					}
					else   cur_size = (unsigned int)(channel->end + channel->max_size + sizeof(int) - channel->start);
					if(cur_size >= lib_channels[i].sampleSize){
						read_lib_port(i, (unsigned char*)buf, lib_channels[i].sampleSize);
						write(bConnId[id], &lib_channels[i].channel_id, sizeof(unsigned char));
						write(bConnId[id], buf, lib_channels[i].sampleSize);
						isWriteEnd = 1;
						break;
					}
				}
			}
			if(isWriteEnd == 1)	break;
		}
	}
  }
}
*/

void bluetoothMasterInit(int id){
	struct sockaddr_rc addr = { 0 };
	int status;

	bConnId[id] = socket (AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);

	addr.rc_family = AF_BLUETOOTH;
	addr.rc_channel = (uint8_t) 1;
	str2ba (address[id], &addr.rc_bdaddr);

	status = connect (bConnId[id], (struct sockaddr *) &addr, sizeof(addr));

	if(status == 0) printf ("id:%d connect\n", id);
	else	printf("id:%d connect FAIL!!!(due to %d)\n", id, errno);
}

void bluetoothMasterRun(){
	int i=0;
	
	//address[0] = // fill it (ex. "00:16:53:07:50:7C";	//nxt
	//address[1] = // fill it (ex. "00:6A:8E:16:C8:4E";	//ti
##CONNECTION_ADDRESS_DEFINE
	
	for(i=0; i<NUM_BLUETOOTH_CONNECTION; i++){
		bluetoothMasterInit(i);
		THREAD_CREATE(&bluetoothMasterThread[i], bluetoothMasterRoutine, (void*)i);
	}
}

##BLUETOOTH_MASTER_END