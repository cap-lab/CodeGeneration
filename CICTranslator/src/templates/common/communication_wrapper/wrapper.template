##COMM_WRAPPER_CODE_START
static int get_channel_index(int ch_id);

THREAD_FUNC_RET_TYPE SenderRoutine(THREAD_FUNC_ARG_TYPE pdata){
    unsigned char buf[1024] = {0, };
    int index; 
    int ready_to_send;
    unsigned char size;
    while(1)
    {
        for (index = 0; index < num_connMap; index++)
        {        
        	ready_to_send = 0;
            if(connMap[index].lib_or_ch == CON_NOR_CHANNEL) 
            {                
                int channel_index = get_channel_index(connMap[index].channel_id);
                
                for(j = 0; j < num_portmaps; j++)
				{
					if(addressmap[j].channel_id == connMap[index].channel_id)
					{
					  break;
					}
				}

				if(j >= num_portmaps)
				  continue;

                if(channels[channel_index].type == CHANNEL_TYPE_NORMAL)
                {
                    int cur_size = MQ_AVAILABLE(channel_index);
                    if(cur_size >= channels[channel_index].sampleSize && addressmap[j].op == 'w')
                    {                        
                        memcpy(&buf[0], &connMap[index].lib_or_ch, sizeof(int32_t));
						memcpy(&buf[0]+sizeof(int32_t), &connMap[index].channel_id, sizeof(int32_t));
						MQ_RECEIVE(channel_index, &buf[0]+(2*sizeof(int32_t)), channels[channel_index].sampleSize);
              
                        size = (unsigned char)channels[channel_index].sampleSize + 2*sizeof(int32_t);
                        
                        ready_to_send = 1;                                          
                    }
                }
                else if(channels[channel_index].type == CHANNEL_TYPE_BUFFER)
                {
                    memcpy(&buf[0], &connMap[index].lib_or_ch, sizeof(int32_t));
                    memcpy(&buf[0]+sizeof(int32_t), &connMap[index].channel_id, sizeof(int32_t));
                    BUF_RECEIVE(channel_index, &buf[0]+(2*sizeof(int32_t)), channels[channel_index].sampleSize);
                    size = (unsigned char)channels[channel_index].sampleSize + 2*sizeof(int32_t);
					
					ready_to_send = 1;                   
                }
                else if(channels[channel_index].type == CHANNEL_TYPE_ARRAY_CHANNEL)
                {
                    ;//?? 
                }
                else
                {
                	ready_to_send = 0;
                    ;//error handling 
                }
            } // end of CON_NOR_CHANNEL
            else if(connMap[index].lib_or_ch == CON_LIB_CHANNEL) 
            {
                int lib_ch_index = init_lib_port(connMap[index].channel_id, 'w');
                int cur_size = LIB_CHECK(lib_ch_index);

                if(cur_size >= lib_channels[lib_ch_index].sampleSize)
                {
                    memcpy(&buf[0], &connMap[index].lib_or_ch, sizeof(int32_t));
                    memcpy(&buf[0]+sizeof(int32_t), &connMap[index].channel_id, sizeof(int32_t));
                    LIB_RECEIVE(lib_ch_index, &buf[0]+(2*sizeof(int32_t)), lib_channels[lib_ch_index].sampleSize);
                    size = (unsigned char)lib_channels[lib_ch_index].sampleSize + 2*sizeof(int32_t);
					
					ready_to_send = 1;
                }
            } // end of CON_LIB_CHANNEL
            
            if(ready_to_send == 1)
            {
##SENDER_SPECIFIC
            }               
        } // end of for 
    } // end of while(1) 
}

void OutConnMasterRun()
{
    int i;
    
##BOOL_SPECIFIC

    for( i = 0; i < num_connMap; i++)
    {
##CREATE_SPECIFIC_RECEIVER
    }

    if(num_connMap > 0)
        THREAD_CREATE(&outCommThread[num_connMap], SenderRoutine, NULL);
}
##COMM_WRAPPER_CODE_END