##COMM_SLAVE_CODE_START
typedef struct {
    unsigned int channel_id;
 
    unsigned char buf[1024];
    int start;
    int end;
    int max_size;
    int cur_size;
    int isFull;

    MUTEX_TYPE mutex;
    COND_TYPE cond;

    int canIStart;
} SHM_CHANNEL;

##SHM_CHANNEL_DEFINE
##SHM_KEY
SHM_CHANNEL* shm_channels[2];   // 2* NUM_SHARED_CONNECTION 
static int KEY_NUM[NUM_SHARED_CONNECTION] = {9011};

#define num_shmchannels (int)(sizeof(shm_channels)/sizeof(shm_channels[0]))

#include <sys/shm.h> 
int shm_id; 
void* shm_memory;
struct shmid_ds shm_info;

static int get_channel_index(int ch_id);

#define SHM_AVAILABLE() shm_available()
#define SHM_RECEIVE(a, b) read_shm_port((unsigned char *)a, b)
#define SHM_SEND(a, b) write_shm_port((unsigned char *)a, b)

##SHM_PORT_DEFINE 
#define SEND_PORT 1
#define RECEIVE_PORT 0

void SMInit()
{
    int index, i; 
    for(index = 0; index < NUM_SHARED_CONNECTION; index++)
    {
        shm_id = shmget((key_t)KEY_NUM[index], sizeof(SHM_CHANNEL)*2*1, IPC_CREAT|0666);
        if(shm_id == -1)
        {
            printf("Fail to get SHM!\n");
            exit(1);
        }

        shm_memory = shmat(shm_id, (void*)0, 0);
        if(shm_memory == (void*) -1)
        {
            printf("Fail to attach SHM!\n");
            exit(1);
        }

        printf("success SHM attached!\n");
        ##SHM_CHANNEL_ASSIGN
        shm_channels[0] = (SHM_CHANNEL*)shm_memory;
        shm_channels[1] = (SHM_CHANNEL*)(shm_memory + sizeof(SHM_CHANNEL));

        printf("111111111: i'm Robot <<<<<< \n");

         while(1)
        {
            int result = 0; 

            for(i = 0; i < num_shmchannels; i++)
            {
                /*
                MUTEX_INIT(&(shm_channels[i]->mutex));
                COND_INIT(&(shm_channels[i]->cond));

                shm_channels[i]->start = 0; //lib_channels[i]->buf; //&(lib_channels[i]->buf[0]);
                shm_channels[i]->end = 0; //lib_channels[i]->buf; //&(lib_channels[i]->buf[0]);
                shm_channels[i]->cur_size =0;
                shm_channels[i]->isFull = 0;

                shm_channels[i]->channel_id = i;
                memset(shm_channels[i]->buf, 0, sizeof(shm_channels[i]->buf));
                shm_channels[i]->max_size = 1024; 
                */

                result += shm_channels[i]->canIStart;
            }
			
            if(result == num_shmchannels)
                break;
            else
            {  
                printf("i'm caller: waiting for set up..... %d\n", result);
                fflush(stdout);
                sleep(1);
            }
        }

        printf("$$$ shm_channels $$$ shm_channels Init is DONE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
    }
   
}

int shm_available() // non-blocking // SHM_AVAILABLE
{
    int ret;

    MUTEX_LOCK(&(shm_channels[RECEIVE_PORT]->mutex));

    if(shm_channels[RECEIVE_PORT]->start <= shm_channels[RECEIVE_PORT]->end) 
    {
        ret = (unsigned int)(shm_channels[RECEIVE_PORT]->end - shm_channels[RECEIVE_PORT]->start);
        if(ret == 0 && shm_channels[RECEIVE_PORT]->isFull == 1) 
            ret = shm_channels[RECEIVE_PORT]->max_size;
    }
    else     ret = (unsigned int)(shm_channels[RECEIVE_PORT]->end + shm_channels[RECEIVE_PORT]->max_size - shm_channels[RECEIVE_PORT]->start);

    MUTEX_UNLOCK(&(shm_channels[RECEIVE_PORT]->mutex));

    printf("[DEBUG] ret: %d\n", ret);
    return ret;
}

int read_shm_port(unsigned char *buf, int len) //SHM_RECEIVE
{
    int available_size=0;

read_shm_start:
    MUTEX_LOCK(&(shm_channels[RECEIVE_PORT]->mutex));

    if(shm_channels[RECEIVE_PORT]->start < shm_channels[RECEIVE_PORT]->end)  
    {
        available_size = (shm_channels[RECEIVE_PORT]->end - shm_channels[RECEIVE_PORT]->start);
    }
    else if(shm_channels[RECEIVE_PORT]->start == shm_channels[RECEIVE_PORT]->end)
    {
      if(shm_channels[RECEIVE_PORT]->isFull == false)      
        available_size = 0; 
      else if(shm_channels[RECEIVE_PORT]->isFull == true) 
        available_size = shm_channels[RECEIVE_PORT]->max_size;
    }
    else    available_size = shm_channels[RECEIVE_PORT]->end + shm_channels[RECEIVE_PORT]->max_size - shm_channels[RECEIVE_PORT]->start;

    if(len > available_size) // blocking case
    {
        COND_WAIT(&(shm_channels[RECEIVE_PORT]->cond), &(shm_channels[RECEIVE_PORT]->mutex));
        MUTEX_UNLOCK(&(shm_channels[RECEIVE_PORT]->mutex));
        goto read_shm_start; // try reading again
    }
    else
        MUTEX_UNLOCK(&(shm_channels[RECEIVE_PORT]->mutex));

    if(shm_channels[RECEIVE_PORT]->start + len <= shm_channels[RECEIVE_PORT]->max_size)   //이부분 바뀌어야함 
    {
        memcpy(buf, &shm_channels[RECEIVE_PORT]->buf[shm_channels[RECEIVE_PORT]->start], len);
        MUTEX_LOCK(&(shm_channels[RECEIVE_PORT]->mutex));
        shm_channels[RECEIVE_PORT]->start += len;
        if(shm_channels[RECEIVE_PORT]->end == shm_channels[RECEIVE_PORT]->start)  
            shm_channels[RECEIVE_PORT]->isFull = false;
        MUTEX_UNLOCK(&(shm_channels[RECEIVE_PORT]->mutex));
    }
    else
    {
        int part = shm_channels[RECEIVE_PORT]->max_size - shm_channels[RECEIVE_PORT]->start;  //이부분 바뀌어야함 
        if(part != 0)
        {
            memcpy(buf, &shm_channels[RECEIVE_PORT]->buf[shm_channels[RECEIVE_PORT]->start], part);
        }
        memcpy(buf + part, shm_channels[RECEIVE_PORT]->buf, len - part);

        MUTEX_LOCK(&(shm_channels[RECEIVE_PORT]->mutex));
        shm_channels[RECEIVE_PORT]->start = len - part;//lib_channels[channel_index]->buf + (len - part);
        if(shm_channels[RECEIVE_PORT]->end == shm_channels[RECEIVE_PORT]->start)  
            shm_channels[RECEIVE_PORT]->isFull = false;
        MUTEX_UNLOCK(&(shm_channels[RECEIVE_PORT]->mutex));
    }
    
    
    COND_BROADCAST(&(shm_channels[RECEIVE_PORT]->cond));

    return len;
}

int write_shm_port(unsigned char *buf, int len)  //SHM_SEND
{
    int available_size=0;

write_shm_start:
    MUTEX_LOCK(&(shm_channels[SEND_PORT]->mutex));

    if(shm_channels[SEND_PORT]->start < shm_channels[SEND_PORT]->end)  
    {
        available_size = (unsigned int)(shm_channels[SEND_PORT]->end - shm_channels[SEND_PORT]->start);
    }
    else if(shm_channels[SEND_PORT]->start == shm_channels[SEND_PORT]->end)
    {
      if(shm_channels[SEND_PORT]->isFull == false)       
        available_size = 0;
      else if(shm_channels[SEND_PORT]->isFull == true)  
        available_size = shm_channels[SEND_PORT]->max_size;
    }
    else   
        available_size = (unsigned int)(shm_channels[SEND_PORT]->end + shm_channels[SEND_PORT]->max_size - shm_channels[SEND_PORT]->start);

    if(len + available_size > shm_channels[SEND_PORT]->max_size)// || shm_channels[SEND_PORT]->isFull == 1) // blocking case    //if(len + available_size >= channel->max_size)
    {
        COND_WAIT(&(shm_channels[SEND_PORT]->cond), &(shm_channels[SEND_PORT]->mutex));
        MUTEX_UNLOCK(&(shm_channels[SEND_PORT]->mutex));     
        goto write_shm_start; // try writing again
    }
    else MUTEX_UNLOCK(&(shm_channels[SEND_PORT]->mutex));

    if(shm_channels[SEND_PORT]->max_size >= shm_channels[SEND_PORT]->end + len) //이부분 바뀌어야함 //1st
    {      
        memcpy(&shm_channels[SEND_PORT]->buf[shm_channels[SEND_PORT]->end], buf, len);
        MUTEX_LOCK(&(shm_channels[SEND_PORT]->mutex));
        shm_channels[SEND_PORT]->end += len;
        if(shm_channels[SEND_PORT]->end == shm_channels[SEND_PORT]->start)  
            shm_channels[SEND_PORT]->isFull = true;
        MUTEX_UNLOCK(&(shm_channels[SEND_PORT]->mutex));
    }
    else
    {
        int part = shm_channels[SEND_PORT]->max_size - shm_channels[SEND_PORT]->end;   
        if(part != 0)
        {
            memcpy(&shm_channels[SEND_PORT]->buf[shm_channels[SEND_PORT]->end], buf, part);
        }
        memcpy(shm_channels[SEND_PORT]->buf, buf + part, len - part);    

        MUTEX_LOCK(&(shm_channels[SEND_PORT]->mutex));
        shm_channels[SEND_PORT]->end = len - part; 
        if(shm_channels[SEND_PORT]->end == shm_channels[SEND_PORT]->start)  
            shm_channels[SEND_PORT]->isFull = true;
        MUTEX_UNLOCK(&(shm_channels[SEND_PORT]->mutex));
    }
    
    COND_BROADCAST(&(shm_channels[SEND_PORT]->cond));

    return len;
}
##COMM_SLAVE_CODE_END