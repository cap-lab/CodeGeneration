#ifndef _THREAD_INFO
#define _THREAD_INFO

#define THREAD_FUNC_RET_TYPE static void
#define THREAD_FUNC_ARG_TYPE void*

#define THREAD_TYPE TASKINFO
#define MUTEX_TYPE OS_MUTEX
#define COND_TYPE OS_FLAG_GRP

#define MUTEX_LOCK(a)   my_mutex_lock(a)
#define MUTEX_UNLOCK(a) my_mutex_unlock(a)

#define COND_WAIT(a, b) my_cond_wait(a, b)
#define COND_BROADCAST(a) my_cond_broadcast(a)

#define MUTEX_INIT(a)   my_mutex_init(a)
#define MUTEX_WRAPUP(a) my_mutex_wrapup(a)

#define COND_INIT(a)    my_cond_init(a)
#define COND_WRAPUP(a)  my_cond_wrapup(a)

#define SCHED_YIELD()   my_sched_yield() 

#define THREAD_CREATE(a, b, c)    my_thread_create(a, b, c)
#define THREAD_JOIN(a)            my_thread_join(a)
#define THREAD_CANCEL(a)          my_thread_cancel(a) 

#define MUTEX_INIT_INLINE NULL
#define COND_INIT_INLINE  NULL

#define APP_TASK_ROBOT_START_PRIO 1u
#define APP_TASK_ROBOT_START_STK_SIZE 1024u

#define TASK_STK_SIZE 1024u

typedef struct{
  int prio;
  OS_TCB tcb;
  CPU_STK stk[TASK_STK_SIZE];
} TASKINFO;

static void cic_task_sleep(int index, char op);
static void cic_task_notify(int index, char op);

static void my_mutex_lock(MUTEX_TYPE *mutex)
{
    OS_ERR err;
    OSMutexPend(mutex, 0, OS_OPT_PEND_BLOCKING, NULL, &err);
    if(err != OS_ERR_NONE){
      PRINT("OSMutexPend Error!");
    } 
}

static void my_mutex_unlock(MUTEX_TYPE *mutex)
{
    OS_ERR err;
    OSMutexPost(mutex, OS_OPT_POST_NONE, &err);
    if(err != OS_ERR_NONE){
      PRINT("OSMutexPost Error!");
    } 
}
   
static void my_cond_wait(COND_TYPE *cond, MUTEX_TYPE *mutex)
{

}


static void my_cond_broadcast(COND_TYPE *cond)
{

}

static void my_mutex_init(MUTEX_TYPE *mutex)
{
    OS_ERR err;
    OSMutexCreate(mutex, "mutex", &err);
    if(err != OS_ERR_NONE){
      PRINT("OSMutexCreate Error!");
    } 
}

static void my_mutex_wrapup(MUTEX_TYPE *mutex)
{
    OS_ERR err;
    OSMutexDel(mutex, OS_OPT_DEL_NO_PEND, &err);
    if(err != OS_ERR_NONE){
      PRINT("OSMutexDel Error!");
    } 
}

static void my_cond_init(COND_TYPE *cond)
{
    OS_ERR err;
    OSFlagCreate(cond, "Flag", 0, &err);
    if(err != OS_ERR_NONE){
      PRINT("OSFlagCreate Error!");
    } 
}

static void my_cond_wrapup(COND_TYPE *cond)
{
    OS_ERR err;
    OSFlagDel(cond, OS_OPT_DEL_NO_PEND, &err);
    if(err != OS_ERR_NONE){
      PRINT("OSFlagDel Error!");
    } 
}

static void my_thread_create(TASKINFO* taskinfo, void (*task_routine)(void*), void* task_index)
{
    OS_ERR err;
    
    OSTaskCreate((OS_TCB     *)&(taskinfo->tcb),           /* Create the start task                                */
                 (CPU_CHAR   *)"Task Start",
                 (OS_TASK_PTR ) task_routine,
                 (void       *) (void*)(task_index),
                 (OS_PRIO     ) (taskinfo->prio),
                 (CPU_STK    *)&(taskinfo->stk[0]),
                 (CPU_STK_SIZE) TASK_STK_SIZE / 10u,
                 (CPU_STK_SIZE) TASK_STK_SIZE,
                 (OS_MSG_QTY  ) 0u,
                 (OS_TICK     ) 0u,
                 (void       *) 0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR     *)&err);

    if(err != OS_ERR_NONE){
        PRINT("OSTaskCreate() failed!\n");
    }
}
 
static void my_thread_join(THREAD_TYPE index)
{
   // Need To Fix
}

static void my_thread_cancel(TASKINFO* taskinfo)
{
   // Need To Fix
    OS_ERR err;
    OSTaskDel((OS_TCB     *)&(taskinfo->tcb), (OS_ERR     *)&err);
    
    if(err != OS_ERR_NONE){
        PRINT("OSTaskDel() failed!\n");
    }
}

static void my_sched_yield()
{
    OS_ERR err;
    OSTaskSemPend(1, OS_OPT_PEND_BLOCKING, 0, &err); 
}

#endif
