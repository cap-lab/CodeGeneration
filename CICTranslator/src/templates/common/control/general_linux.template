##MTM_API_START
CIC_T_VOID ExecuteTransition(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name)
{
    CIC_T_INT i=0, j=0;

    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(CIC_F_STRING_COMPARE(tasks[i].name, t_name) == 0){
            for(j=0; j<CIC_ARRAYLEN(mtms); j++){
                if(mtms[j].task_id == tasks[i].parent_task_id){
                    mtms[j].Transition();
                    return;
                }
            }
        }
    }
    CIC_F_ERROR("proc", "ExecuteTransition() fail!", CIC_V_ERROR_EXIT);
}

CIC_T_VOID SetMTMParamInt(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name, CIC_T_CHAR* p_name, long p_value)
{
    CIC_T_INT i=0, j=0;

    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(CIC_F_STRING_COMPARE(tasks[i].name, t_name) == 0){
            for(j=0; j<CIC_ARRAYLEN(mtms); j++){
                if(mtms[j].task_id == tasks[i].parent_task_id){
                    mtms[j].SetVariableInt(p_name, (CIC_T_INT)p_value);
                    return;
                }
            }
        }
    }
    CIC_F_ERROR("proc", "SetMTMParamInt() fail!", CIC_V_ERROR_EXIT);
    return;
}

CIC_T_VOID SetMTMParamString(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name, CIC_T_CHAR* p_name, CIC_T_CHAR* p_value)
{
    return;
}

CIC_T_CHAR* GetCurrentModeName(CIC_T_CHAR* caller_task_name)
{
    CIC_T_INT i=0, j=0;
    CIC_T_CHAR* mode = CIC_V_NULL;

    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(CIC_F_STRING_COMPARE(tasks[i].name, caller_task_name) == 0){
            for(j=0; j<CIC_ARRAYLEN(mtms); j++){
                if(mtms[j].task_id == tasks[i].parent_task_id){
                    mode = mtms[j].GetCurrentModeName(caller_task_name);
                    return mode;
                }
            }
        }
    }
	CIC_F_ERROR("proc", "GetModeCurrentModeName() fail!", CIC_V_ERROR_EXIT);
    return CIC_V_NULL;
}

CIC_T_CHAR* GetMode(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* target_task_name)
{
    CIC_T_INT i=0, j=0;
    CIC_T_CHAR* mode = CIC_V_NULL;

    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(CIC_F_STRING_COMPARE(tasks[i].name, target_task_name) == 0){
            for(j=0; j<CIC_ARRAYLEN(mtms); j++){
                if(mtms[j].task_id == tasks[i].parent_task_id){
                    mode = mtms[j].GetCurrentModeName(target_task_name);
                    return mode;
                }
            }
        }
    }
	CIC_F_ERROR("proc", "GetMode() fail!", CIC_V_ERROR_EXIT);
    return CIC_V_NULL;
}
##MTM_API_END

##CONTROL_API_START
CIC_STATIC CIC_T_INT GetControlChannelIndex(CIC_T_INT control_task_id)
{
	CIC_T_INT i;
	
	for(i=0;i<CIC_UV_CONTROL_CHANNEL_COUNT;i++) {
		if(control_task_id == control_channel[i].control_task_id) {
			return i;
		}
	}
	
	CIC_F_ERROR("proc", "GetControlChannelIndex() fail!", CIC_V_ERROR_EXIT);
	return CIC_V_ERROR;
}

CIC_STATIC CIC_T_INT GetValidTimerSlotId(CIC_T_UINT cont_ch_index)
{
	CIC_T_INT id, temp_slot_index;

	id = control_channel[cont_ch_index].empty_slot_index;
	temp_slot_index = control_channel[cont_ch_index].empty_slot_index + 1;
	if(temp_slot_index>=MAX_TIMER_SLOT_SIZE) // return back to the first time_slot
		temp_slot_index = 0;

	if(control_channel[cont_ch_index].timer_slot[temp_slot_index] != 0) {  // check the next point is available
		CIC_T_UINT cur_time_val = GetCurrentTimeBase();
		if(control_channel[cont_ch_index].timer_slot[temp_slot_index]  <= cur_time_val) {
			control_channel[cont_ch_index].timer_slot[temp_slot_index] = 0;
		}
		else { 																// traverse until it find an available time slot
			for(; temp_slot_index != id; ++temp_slot_index) {
				if(temp_slot_index>=MAX_TIMER_SLOT_SIZE)
					temp_slot_index = 0;
				if(control_channel[cont_ch_index].timer_slot[temp_slot_index] == 0)
					break;
				else if(control_channel[cont_ch_index].timer_slot[temp_slot_index] <= cur_time_val) {
					control_channel[cont_ch_index].timer_slot[temp_slot_index] = 0;
					break;
				}
			}

			if(temp_slot_index == id){
				CIC_F_ERROR("proc", "GetValidTimerSlotId() fail!", CIC_V_ERROR_EXIT);
				return CIC_V_ERROR;
			}
		}
	}

	control_channel[cont_ch_index].empty_slot_index = temp_slot_index;
	return id;
}

CIC_T_VOID SetThroughput(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name, CIC_T_CHAR* value, CIC_T_CHAR* unit)
{

}

CIC_T_VOID SetDeadline(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name, CIC_T_CHAR* value, CIC_T_CHAR* unit)
{

}

CIC_T_INT CheckTaskState(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name)
{
    CIC_T_INT i=0;
    CIC_T_INT task_id=0;

    for(i=0; i<CIC_UV_NUM_TASKS; i++){
        if(CIC_F_STRING_COMPARE(t_name, tasks[i].name) == 0){
            task_id = i;
            break;
        }
    }

    return tasks[task_id].state;
}

CIC_T_VOID CallCICTask(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name)
{
	CIC_T_INT task_index = GetTaskIdFromTaskName(t_name);
	tasks[task_index].state = STATE_RUN;
	TASK_INIT;
	TASK_GO;
	TASK_WRAPUP;
	tasks[task_index].state = STATE_STOP;
}


CIC_T_VOID RunCICTask(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name)
{
##CONTROL_RUN_TASK
}

CIC_T_VOID StopCICTask(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name)
{
##CONTROL_STOP_TASK
}

CIC_T_VOID ResumeCICTask(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name)
{
##CONTROL_RESUME_TASK
}

CIC_T_VOID SuspendCICTask(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name)
{
##CONTROL_SUSPEND_TASK
}

CIC_T_LONG GetParamInt(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name, CIC_T_CHAR* p_name)
{
	CIC_T_LONG ret=0;
	CIC_T_INT i=0;
	CIC_T_CHAR *task_name;
	CIC_T_CHAR *param_name;

	if(t_name == CIC_V_NULL){
		CIC_T_INT task_id = GetTaskIdFromTaskName(caller_task_name);
		task_name = tasks[task_id].name;
		param_name = p_name;
	}
	else{
		task_name = t_name;
		param_name = p_name;
	}

	for(i=0; i<CIC_ARRAYLEN(param_list); i++){
		if(CIC_F_STRING_COMPARE(task_name, param_list[i].task_name) == 0 && CIC_F_STRING_COMPARE(param_name, param_list[i].param_name) == 0){
			ret = (long)(param_list[i].param_value);
			break;
		}
	}

	return ret;
}

CIC_T_VOID SetParamInt(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name, CIC_T_CHAR* p_name, CIC_T_LONG p_value)
{
	CIC_T_INT i=0; 
    CIC_T_INT targetTaskIdFromTaskName = GetTaskIdFromTaskName(t_name);

    for(i=0;i<CIC_ARRAYLEN(param_list);i++) {
        if(targetTaskIdFromTaskName == param_list[i].task_id && CIC_F_STRING_COMPARE(p_name, param_list[i].param_name)==0 ) {
           (param_list[i].param_value) = (CIC_T_VOID*)p_value;
            break;
        }
    }

    return;
}

CIC_T_DOUBLE GetParamFloat(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name, CIC_T_CHAR* p_name)
{
	CIC_T_DOUBLE ret=0;
	CIC_T_INT i=0;
	CIC_T_CHAR *task_name, *param_name;

	if(t_name == CIC_V_NULL){
		CIC_T_INT task_id = GetTaskIdFromTaskName(caller_task_name);
		task_name = tasks[task_id].name;
		param_name = p_name;
	}
	else{
		task_name = t_name;
		param_name = p_name;
	}

	for(i=0; i<CIC_ARRAYLEN(param_list); i++){
		if(CIC_F_STRING_COMPARE(task_name, param_list[i].task_name) == 0 && CIC_F_STRING_COMPARE(param_name, param_list[i].param_name) == 0){
			ret = *((double*)&(param_list[i].param_value));
			break;
		}
	}

	return ret;
}

CIC_T_VOID SetParamFloat(CIC_T_CHAR* caller_task_name, CIC_T_CHAR* t_name, CIC_T_CHAR* p_name, CIC_T_DOUBLE p_value)
{
    CIC_T_INT i=0; 
    CIC_T_INT targetTaskIdFromTaskName = GetTaskIdFromTaskName(t_name);

    for(i=0;i<CIC_ARRAYLEN(param_list);i++) {
        if(targetTaskIdFromTaskName == param_list[i].task_id && CIC_F_STRING_COMPARE(p_name, param_list[i].param_name)==0 ) {
           *((double*)&(param_list[i].param_value)) = p_value;
            break;
        }
    }
	return;
}

CIC_T_INT GetCICTimerAlarmed(CIC_T_CHAR* caller_task_name, CIC_T_UINT timer_id)
{
	CIC_T_UINT my_task_id = GetTaskIdFromTaskName(caller_task_name);
	CIC_T_UINT cont_ch_index = GetControlChannelIndex(my_task_id);

	CIC_T_UINT cur_time = GetCurrentTimeBase();

	if(control_channel[cont_ch_index].timer_slot[timer_id]  <= cur_time) {
		control_channel[cont_ch_index].timer_slot[timer_id]=0; // reset timer
		control_channel[cont_ch_index].empty_slot_index = timer_id;
		return 1;
	}
	else{
		if((control_channel[cont_ch_index].timer_slot[timer_id] - cur_time) >= 50000000){	// overflow_case
			cur_time += 100000000;
			if(control_channel[cont_ch_index].timer_slot[timer_id]  <= cur_time) {
				control_channel[cont_ch_index].timer_slot[timer_id]=0; // reset timer
				control_channel[cont_ch_index].empty_slot_index = timer_id;
				return 1;
			}
			else return 0;
		}
		else return 0;
	}
	return 0;
}

CIC_T_INT SetCICTimer(CIC_T_CHAR* caller_task_name, CIC_T_UINT time_value, CIC_T_CHAR *time_unit) 
{
	CIC_T_INT timer_id;
	CIC_T_UINT tick;
	CIC_T_UINT my_task_id = GetTaskIdFromTaskName(caller_task_name);
	CIC_T_UINT cont_ch_index = GetControlChannelIndex(my_task_id);
	timer_id = GetValidTimerSlotId(cont_ch_index);
        
    tick = ChangeTimeUnit(time_value, time_unit);

	control_channel[cont_ch_index].timer_slot[timer_id] = GetCurrentTimeBase() + tick;
	return timer_id; 
}

CIC_T_VOID ResetCICTimer(CIC_T_CHAR* caller_task_name, CIC_T_UINT timer_id) 
{
	CIC_T_UINT my_task_id = GetTaskIdFromTaskName(caller_task_name);
	CIC_T_UINT cont_ch_index = GetControlChannelIndex(my_task_id);
	control_channel[cont_ch_index].timer_slot[timer_id]=0; // reset timer
}
##CONTROL_API_END