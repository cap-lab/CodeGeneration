/*
 * uem_data_template.c
 *
 *  Created on: 2017. 9. 7.
 *      Author: jej
 */


// ##TASK_CODE_TEMPLATE::START
// ##FLAT_TASK_LOOP::START
void /*[NESTED_TASK_NAME]*/_Init/*[TASK_FUNCTION_ID]*/(int nTaskId);
void /*[NESTED_TASK_NAME]*/_Go/*[TASK_FUNCTION_ID]*/();
void /*[NESTED_TASK_NAME]*/_Wrapup/*[TASK_FUNCTION_ID]*/();
// ##FLAT_TASK_LOOP::END
// ##TASK_CODE_TEMPLATE::END

// ##CHANNEL_SIZE_DEFINITION_TEMPLATE::START
// ##CHANNEL_LOOP::START
#define CHANNEL_/*[CHANNEL_ID]*/_SIZE (/*[CHANNEL_SIZE]*/)
// ##CHANNEL_LOOP::END
// ##CHANNEL_SIZE_DEFINITION_TEMPLATE::END

// ##CHANNEL_BUFFER_DEFINITION_TEMPLATE::START
// ##CHANNEL_LOOP::START
char s_pChannel_/*[CHANNEL_ID]*/_buffer[CHANNEL_/*[CHANNEL_ID]*/_SIZE];
// ##CHANNEL_LOOP::END
// ##CHANNEL_BUFFER_DEFINITION_TEMPLATE::END

// ##CHUNK_DEFINITION_TEMPLATE::START
// ##CHANNEL_LOOP::START
SChunk g_astChunk_channel_/*[CHANNEL_ID]*/_out[] = {
// ##CHUNK_LOOP::START
	{
		s_pChannel_/*[CHANNEL_ID]*/_buffer/*[CHUNK_LOOP_ADDRESS]*/, // Chunk start pointer
		s_pChannel_/*[CHANNEL_ID]*/_buffer/*[CHUNK_LOOP_ADDRESS]*/, // Data start pointer
		s_pChannel_/*[CHANNEL_ID]*/_buffer/*[CHUNK_LOOP_ADDRESS]*/, // Data end pointer
		0, // Written data length
		0, // Available data number;
	},
// ##CHUNK_LOOP::END
};

SChunk g_astChunk_channel_/*[CHANNEL_ID]*/_in[] = {
// ##CHUNK_LOOP::START
	{
		s_pChannel_/*[CHANNEL_ID]*/_buffer/*[CHUNK_LOOP_ADDRESS]*/, // Chunk start pointer
		s_pChannel_/*[CHANNEL_ID]*/_buffer/*[CHUNK_LOOP_ADDRESS]*/, // Data start pointer
		s_pChannel_/*[CHANNEL_ID]*/_buffer/*[CHUNK_LOOP_ADDRESS]*/, // Data end pointer
		0, // Written data length
		0, // Available data number;
	},
// ##CHUNK_LOOP::END
};

// ##CHANNEL_LOOP::END
// ##CHUNK_DEFINITION_TEMPLATE::END


// ##PORT_SAMPLE_RATE_TEMPLATE::START
// ##CHANNEL_LOOP::START
SPortSampleRate g_astPortSampleRate_/*[INPUT_PORT_NESTED_TASK_NAME]*/_/*[INPUT_PORT_NAME]*/[] = {
// ##INPUT_PORT_MODE_LOOP::START
	{ 	/*[MODE_NAME]*/, // Mode name
		/*[MODE_SAMPLE_RATE]*/, // Sample rate
		/*[BROADCAST_LOOP_COUNT]*/, // Available number of data
	},
// ##INPUT_PORT_MODE_LOOP::END	
};

SPortSampleRate g_astPortSampleRate_/*[OUTPUT_PORT_NESTED_TASK_NAME]*/_/*[OUTPUT_PORT_NAME]*/[] = {
// ##INPUT_PORT_MODE_LOOP::START
	{ 	/*[MODE_NAME]*/, // Mode name
		/*[MODE_SAMPLE_RATE]*/, // Sample rate
		/*[BROADCAST_LOOP_COUNT]*/, // Available number of data
	},
// ##INPUT_PORT_MODE_LOOP::END	
};
// ##CHANNEL_LOOP::END
// ##PORT_SAMPLE_RATE_TEMPLATE::END


// ##AVAILABLE_CHUNK_LIST_TEMPLATE::START
// ##CHANNEL_LOOP::START
SAvailableChunk g_astAvailableInputChunk_channel_/*[CHANNEL_ID]*/[] = {
// ##CHUNK_LOOP::START
	{ /*[CHUNK_LOOP_INDEX]*/, 0, NULL, NULL, },
// ##CHUNK_LOOP::END
};
// ##CHANNEL_LOOP::END
// ##AVAILABLE_CHUNK_LIST_TEMPLATE::END



// ##TASK_FUNCTION_LIST::START
// ##FLAT_TASK_LOOP::START
STaskFunctions g_ast_MatA_functions[] = {
// ##TASK_FUNCTION_LOOP::START
	{
		/*[NESTED_TASK_NAME]*/_Init/*[TASK_FUNCTION_ID]*/, // Task init function
		/*[NESTED_TASK_NAME]*/_Go/*[TASK_FUNCTION_ID]*/, // Task go function
		/*[NESTED_TASK_NAME]*/_Wrapup/*[TASK_FUNCTION_ID]*/, // Task wrapup function
	},
// ##TASK_FUNCTION_LOOP::END
};
// ##FLAT_TASK_LOOP::END
// ##TASK_FUNCTION_LIST::END



// ##CHANNEL_LIST_TEMPLATE::START
SChannel g_astChannels[] = {
// ##CHANNEL_LOOP::START
	{
		/*[CHANNEL_ID]*/, // Channel ID
		/*[CHANNEL_COMMUNICATION_TYPE]*/, // Channel communication type
		/*[CHANNEL_TYPE]*/, // Channel type
		s_pChannel_/*[CHANNEL_ID]*/_buffer, // Channel buffer pointer
		CHANNEL_/*[CHANNEL_ID]*/_SIZE, // Channel size
		s_pChannel_/*[CHANNEL_ID]*/_buffer, // Channel data start
		s_pChannel_/*[CHANNEL_ID]*/_buffer, // Channel data end
		0, // Channel data length
		0, // reference count
		NULL, // Mutex
		NULL, // Event
		{
			/*[INPUT_PORT_TASK_ID]*/, // Task ID
			/*[INPUT_PORT_NAME]*/, // Port name
			/*[INPUT_PORT_SAMPLE_RATE_TYPE]*/, // Port sample rate type
			g_astPortSampleRate_/*[INPUT_PORT_NESTED_TASK_NAME]*/_/*[INPUT_PORT_NAME]*/, // Array of sample rate list
			/*[INPUT_PORT_MODE_NUM]*/, // Array element number of sample rate list
			0, //Selected sample rate index
			/*[INPUT_PORT_SAMPLE_SIZE]*/, // Sample size
			/*[INPUT_PORT_TYPE]*/, // Port type
			NULL, // Pointer to Subgraph port
		}, // Input port information
		{
			/*[OUTPUT_PORT_TYPE]*/, // Task ID
			/*[OUTPUT_PORT_NAME]*/, // Port name
			/*[OUTPUT_PORT_SAMPLE_RATE_TYPE]*/, // Port sample rate type
			g_astPortSampleRate_/*[OUTPUT_PORT_NESTED_TASK_NAME]*/_/*[OUTPUT_PORT_NAME]*/, // Array of sample rate list
			/*[OUTPUT_PORT_MODE_NUM]*/, // Array element number of sample rate list
			0, //Selected sample rate index
			/*[OUTPUT_PORT_SAMPLE_SIZE]*/, // Sample size
			/*[OUTPUT_PORT_TYPE]*/, // Port type
			NULL, // Pointer to Subgraph port
		}, // Output port information
		{
			g_astChunk_channel_/*[CHANNEL_ID]*/_in, // Array of chunk
			1, // Chunk number
			1, // Chunk size
		}, // Input chunk information
		{
			g_astChunk_channel_/*[CHANNEL_ID]*/out, // Array of chunk
			1, // Chunk number
			1, // Chunk size
		}, // Output chunk information
		CHUNK_NUM_NOT_INITIALIZED, // Written output chunk number
		g_astAvailableInputChunk_channel_/*[CHANNEL_ID]*/, // Available chunk list
		/*[MAXIMUM_CHUNK_NUM]*/,
		NULL, // Chunk list head
		NULL, // Chunk list tail
	},
// ##CHANNEL_LOOP::END
};
// ##CHANNEL_LIST_TEMPLATE::END

// ##TASK_LIST_TEMPLATE::START
// ##TASKGRAPH_LOOP::START
STask g_astTasks_/*[TASKGRAPH_NAME]*/[] = {
// ##TASK_LOOP::START
	{ 	/*[TASK_ID]*/, // Task ID
		/*[NESTED_TASK_NAME]*/, // Task name
		/*[TASK_TYPE]*/, // Task Type
		g_ast_/*[NESTED_TASK_NAME]*/_functions, // Task function array
		/*[NUM_OF_TASK_FUNCTION]*/, // Task function array number
		/*[NESTED_TASK_NAME]*/_Init, // Task init function
		/*[NESTED_TASK_NAME]*/_Go, // Task go function
		/*[NESTED_TASK_NAME]*/_Wrapup, // Task wrapup function
		/*[TASK_RUN_CONDITION]*/, // Run condition
		1, // Run rate
		/*[TASK_PERIOD]*/, // Period
		/*[TASK_PERIOD_METRIC]*/, // Period metric
		NULL, // Subgraph
		&g_stGraph_/*[TASKGRAPH_NAME]*/, // Parent task graph
		NULL, // MTM information
		NULL, // Loop information
		NULL, // Task parameter information
		/*[TASK_SCHEDULED]*/, // Statically scheduled or not
		NULL, // Mutex
		NULL, // Conditional variable
	},
// ##TASK_LOOP::END
};
// ##TASKGRAPH_LOOP::END
// ##TASK_LIST_TEMPLATE::END

// ##TASK_GRAPH_TEMPLATE::START
// ##TASKGRAPH_LOOP::START
STaskGraph g_stGraph_/*[TASKGRAPH_NAME]*/ = {
		/*[TASK_GRAPH_TYPE]*/, // Task graph type
		g_astTasks_/*[TASKGRAPH_NAME]*/, // current task graph's task list
		NULL, // parent task
};
// ##TASKGRAPH_LOOP::END
// ##TASK_GRAPH_TEMPLATE::END

// ##TASK_ID_TO_TASK_MAP_TEMPLATE::START
STaskIdToTaskMap g_astTaskIdToTask[] = {
// ##TASKGRAPH_LOOP::START
	{ 	/*[TASK_ID]*/, // Task ID
		/*[NESTED_TASK_NAME]*/, // Task name
		&/*[TASK_POINTER_NAME]*/, // Task structure pointer
	},
// ##TASKGRAPH_LOOP::END
};
// ##TASK_ID_TO_TASK_MAP_TEMPLATE::END


// ##PROCESSOR_INFO_TEMPLATE::START
SProcessor g_astProcessorInfo[] = {
// ##PROCESSOR_LOOP::START
	{ 	/*[PROCESSOR_ID]*/, // Processor ID
		/*[PROCESSOR_IS_CPU]*/, // Processor is CPU?			
		/*[PROCESSOR_NAME]*/, // Processor name
		/*[PROCESSOR_POOL_SIZE]*/, // Processor pool size
	},
// ##PROCESSOR_LOOP::END
};
// ##PROCESSOR_INFO_TEMPLATE::END


// ##SCHEDULED_COMPOSITE_TASKS_TEMPLATE::START

// ##SCHEDULED_COMPOSITE_TASKS_TEMPLATE::END
SScheduledTasks g_astScheduledTaskList[] = {
// ##SCHEDULED_TASKS_LOOP::START
	{	/*[PARENT_TASK_ID]*/, // Parent Task ID
		/*[MODE_ID]*/, // Mode transition mode ID
		/*[SCHEDULE_LIST]*/, // schedule list per throught constraint
		/*[NUM_OF_SCHEDULES]*/, // The number of schedules in the schedule list
		0, // Schedule Index (Default to set 0)
		/*[SEQUENCE_IN_MODE]*/, // Mode Sequence ID 
	},
// ##SCHEDULED_TASKS_LOOP::END
};

// ##MAPPING_SCHEDULING_INFO_TEMPLATE::START
SMappingSchedulingInfo g_astMappingAndSchedulingInfo[] = {
// ##TASK_MAPPING_LOOP::START
	{	/*[MAPPED_TASK_TYPE]*/, // Task type
		{ /*[MAPPED_TASK_INFO]*/ }, // Task ID or composite task information
		/*[MAPPED_PROCESSOR_ID]*/, // Processor ID
		/*[MAPPED_PROCESSOR_ID_LOCAL_ID]*/, // Processor local ID
	},
// ##TASK_MAPPING_LOOP::END
};
// ##MAPPING_SCHEDULING_INFO_TEMPLATE::END




